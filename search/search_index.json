{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigation of the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is governed by the basic equations of motion under constant acceleration due to gravity. To derive the equations, we consider two components of motion: horizontal (x-direction) and vertical (y-direction). 1.1 Equations of Motion In projectile motion, the only force acting on the projectile (ignoring air resistance) is gravity, which accelerates the object downward with a constant acceleration, \\( g \\) . The horizontal and vertical motions are independent of each other. We can describe each with kinematic equations: Horizontal motion (no acceleration) : $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ where: \\( v_0 \\) is the initial velocity, \\( \\theta \\) is the angle of projection, \\( t \\) is time. Vertical motion (constant acceleration due to gravity) : $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ 1.2 Time of Flight To find the time of flight, we need to determine when the projectile hits the ground, i.e., when \\( y(t) = 0 \\) . Using the vertical motion equation: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factoring out \\( t \\) , we get: \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] The solutions are \\( t = 0 \\) (the initial launch) and \\( t = \\frac{2 v_0 \\sin(\\theta)}{g} \\) (the time when the projectile hits the ground). Thus, the time of flight is: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 1.3 Horizontal Range The horizontal range \\( R \\) is the distance traveled in the horizontal direction during the time of flight. From the horizontal motion equation: \\[ R = x(t_f) = v_0 \\cos(\\theta) \\cdot t_f \\] Substituting the expression for \\( t_f \\) : \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 1.4 Family of Solutions This equation shows how the range \\( R \\) depends on the initial velocity \\( v_0 \\) , the gravitational acceleration \\( g \\) , and the launch angle \\( \\theta \\) . The term \\( \\sin(2\\theta) \\) shows that the range is maximized when \\( \\theta = 45^\\circ \\) because \\( \\sin(90^\\circ) = 1 \\) . Thus, for a given \\( v_0 \\) and \\( g \\) , the range depends on the launch angle. The solution also highlights that the range is symmetric: for any angle \\( \\theta \\) , there is a complementary angle \\( 90^\\circ - \\theta \\) that gives the same range. 2. Analysis of the Range 2.1 Dependence on Launch Angle From the derived equation \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) , we can see that the horizontal range is a function of \\( \\sin(2\\theta) \\) . Therefore, the range is: Maximized at \\( \\theta = 45^\\circ \\) , where \\( \\sin(90^\\circ) = 1 \\) . Zero at \\( \\theta = 0^\\circ \\) and \\( \\theta = 90^\\circ \\) , since \\( \\sin(0^\\circ) = 0 \\) and \\( \\sin(180^\\circ) = 0 \\) . Symmetrical around \\( \\theta = 45^\\circ \\) . 2.2 Dependence on Initial Velocity and Gravitational Acceleration From the equation for the range, we observe that the range \\( R \\) is directly proportional to the square of the initial velocity \\( v_0 \\) and inversely proportional to the gravitational acceleration \\( g \\) . Therefore: Initial velocity : As \\( v_0 \\) increases, the range increases quadratically. This implies that doubling the initial velocity quadruples the range. Gravitational acceleration : The range decreases with an increase in gravitational acceleration, so on a planet with stronger gravity, the range of a projectile would be shorter. 3. Practical Applications This model is a simplified version of projectile motion, which assumes no air resistance and level ground. In real-world applications, several factors influence projectile motion: Air resistance : Drag forces reduce the horizontal range and make the trajectory curve differently. The more streamlined the projectile, the less drag it experiences. Uneven terrain : The model assumes level ground, but if the projectile is launched at an incline or on a hill, the calculations become more complex. Wind : Wind can modify both the trajectory and range by altering the horizontal velocity of the projectile. 4. Implementation Below is a Python script to simulate projectile motion and visualize the range as a function of the launch angle for different initial velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Function to calculate the range based on angle and initial velocity def calculate_range(v0, angle): # Convert angle to radians theta = np.radians(angle) # Range formula R = (v0\\*_2 _ np.sin(2\\*theta)) / g return R # Generate data for multiple initial velocities initial_velocities = [20, 30, 40, 50] # Different initial velocities in m/s angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Plotting plt.figure(figsize=(10,6)) for v0 in initial_velocities: ranges = [calculate_range(v0, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"Investigation of the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigation-of-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigation of the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is governed by the basic equations of motion under constant acceleration due to gravity. To derive the equations, we consider two components of motion: horizontal (x-direction) and vertical (y-direction).","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"In projectile motion, the only force acting on the projectile (ignoring air resistance) is gravity, which accelerates the object downward with a constant acceleration, \\( g \\) . The horizontal and vertical motions are independent of each other. We can describe each with kinematic equations: Horizontal motion (no acceleration) : $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ where: \\( v_0 \\) is the initial velocity, \\( \\theta \\) is the angle of projection, \\( t \\) is time. Vertical motion (constant acceleration due to gravity) : $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"To find the time of flight, we need to determine when the projectile hits the ground, i.e., when \\( y(t) = 0 \\) . Using the vertical motion equation: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factoring out \\( t \\) , we get: \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] The solutions are \\( t = 0 \\) (the initial launch) and \\( t = \\frac{2 v_0 \\sin(\\theta)}{g} \\) (the time when the projectile hits the ground). Thus, the time of flight is: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-horizontal-range","text":"The horizontal range \\( R \\) is the distance traveled in the horizontal direction during the time of flight. From the horizontal motion equation: \\[ R = x(t_f) = v_0 \\cos(\\theta) \\cdot t_f \\] Substituting the expression for \\( t_f \\) : \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1.3 Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions","text":"This equation shows how the range \\( R \\) depends on the initial velocity \\( v_0 \\) , the gravitational acceleration \\( g \\) , and the launch angle \\( \\theta \\) . The term \\( \\sin(2\\theta) \\) shows that the range is maximized when \\( \\theta = 45^\\circ \\) because \\( \\sin(90^\\circ) = 1 \\) . Thus, for a given \\( v_0 \\) and \\( g \\) , the range depends on the launch angle. The solution also highlights that the range is symmetric: for any angle \\( \\theta \\) , there is a complementary angle \\( 90^\\circ - \\theta \\) that gives the same range.","title":"1.4 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-launch-angle","text":"From the derived equation \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) , we can see that the horizontal range is a function of \\( \\sin(2\\theta) \\) . Therefore, the range is: Maximized at \\( \\theta = 45^\\circ \\) , where \\( \\sin(90^\\circ) = 1 \\) . Zero at \\( \\theta = 0^\\circ \\) and \\( \\theta = 90^\\circ \\) , since \\( \\sin(0^\\circ) = 0 \\) and \\( \\sin(180^\\circ) = 0 \\) . Symmetrical around \\( \\theta = 45^\\circ \\) .","title":"2.1 Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-dependence-on-initial-velocity-and-gravitational-acceleration","text":"From the equation for the range, we observe that the range \\( R \\) is directly proportional to the square of the initial velocity \\( v_0 \\) and inversely proportional to the gravitational acceleration \\( g \\) . Therefore: Initial velocity : As \\( v_0 \\) increases, the range increases quadratically. This implies that doubling the initial velocity quadruples the range. Gravitational acceleration : The range decreases with an increase in gravitational acceleration, so on a planet with stronger gravity, the range of a projectile would be shorter.","title":"2.2 Dependence on Initial Velocity and Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model is a simplified version of projectile motion, which assumes no air resistance and level ground. In real-world applications, several factors influence projectile motion: Air resistance : Drag forces reduce the horizontal range and make the trajectory curve differently. The more streamlined the projectile, the less drag it experiences. Uneven terrain : The model assumes level ground, but if the projectile is launched at an incline or on a hill, the calculations become more complex. Wind : Wind can modify both the trajectory and range by altering the horizontal velocity of the projectile.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate projectile motion and visualize the range as a function of the launch angle for different initial velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Function to calculate the range based on angle and initial velocity def calculate_range(v0, angle): # Convert angle to radians theta = np.radians(angle) # Range formula R = (v0\\*_2 _ np.sin(2\\*theta)) / g return R # Generate data for multiple initial velocities initial_velocities = [20, 30, 40, 50] # Different initial velocities in m/s angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Plotting plt.figure(figsize=(10,6)) for v0 in initial_velocities: ranges = [calculate_range(v0, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"PROBLEM 2 1. Theoretical Foundation The Forced Damped Pendulum Model The motion of a forced damped pendulum can be described by the following second-order ordinary differential equation (ODE): \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) is the angular displacement of the pendulum as a function of time, \\( \\gamma \\) is the damping coefficient (representing the frictional or resistive forces), \\( \\omega_0 \\) is the natural frequency of the pendulum (which depends on the length and acceleration due to gravity), \\( F_0 \\) is the amplitude of the external driving force, \\( \\omega \\) is the driving angular frequency, and \\( t \\) is time. This equation describes the motion of the pendulum under the influence of both damping and an external periodic force. The term \\( 2 \\gamma \\theta'(t) \\) represents the damping force, \\( \\omega_0^2 \\theta(t) \\) represents the restoring force due to gravity, and \\( F_0 \\cos(\\omega t) \\) is the periodic driving force. Small-Angle Approximation For small oscillations, we can assume that the angle \\( \\theta(t) \\) is small enough that \\( \\sin(\\theta(t)) \\approx \\theta(t) \\) , simplifying the equation of motion to: \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] This is a standard forced damped harmonic oscillator equation, which is more analytically tractable. The solution to this equation depends on several factors, including the damping coefficient, driving frequency, and driving amplitude. Approximate Solution for the Forced Damped Pendulum The general solution to the equation consists of two parts: Homogeneous Solution (related to the system's natural dynamics without the external force): $$ \\theta_h(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) $$ Where \\( A \\) and \\( \\phi \\) are constants determined by initial conditions, and the exponential decay factor \\( e^{-\\gamma t} \\) represents the damping of the system over time. Particular Solution (due to the external driving force): For a steady-state solution, we assume the system reaches a constant amplitude oscillation due to the external force. This solution can be written as: $$ \\theta_p(t) = B \\cos(\\omega t - \\delta) $$ Where \\( B \\) is the amplitude of oscillation and \\( \\delta \\) is the phase shift between the external force and the oscillation. Substituting this into the differential equation and solving for \\( B \\) and \\( \\delta \\) gives us the particular solution: $$ B = \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} $$ $$ \\delta = \\tan^{-1}\\left(\\frac{2 \\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right) $$ Thus, the complete solution to the equation is: \\[ \\theta(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) + \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} \\cos(\\omega t - \\delta) \\] Resonance Conditions and Energy Implications Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) of the pendulum. At resonance, the amplitude of oscillation \\( B \\) becomes large because the denominator in the expression for \\( B \\) becomes very small. In practice, resonance results in the system absorbing maximum energy from the external driving force. The energy absorbed by the system at resonance can be significant, and the oscillation amplitude grows, potentially leading to large motions. This behavior is especially important in engineering, where resonance must be avoided in structures like bridges and buildings to prevent catastrophic failure. 2. Analysis of Dynamics Influence of Damping Coefficient, Driving Amplitude, and Frequency Damping Coefficient ( \\( \\gamma \\) ): As \\( \\gamma \\) increases, the system's oscillations decay more rapidly, reducing the amplitude of oscillation. High damping can suppress resonance effects, limiting the system's ability to oscillate at high amplitudes. Driving Amplitude ( \\( F_0 \\) ): Increasing \\( F_0 \\) increases the amplitude of the system\u2019s steady-state oscillations. However, at very high \\( F_0 \\) , the system may exhibit nonlinear behavior, and the simple harmonic approximation may no longer be valid. Driving Frequency ( \\( \\omega \\) ): The driving frequency affects the resonance condition. If \\( \\omega \\) is close to \\( \\omega_0 \\) , resonance occurs, and the amplitude of oscillations becomes large. Away from resonance, the amplitude decreases. Transition from Regular to Chaotic Motion As the driving amplitude or frequency is varied, the system can transition from regular periodic oscillations to chaotic motion. This can be characterized by sensitivity to initial conditions, where small changes in initial displacement or velocity lead to dramatically different behavior over time. The transition to chaos can be studied using bifurcation diagrams and Poincar\u00e9 sections . 3. Practical Applications Energy Harvesting Devices: The forced damped pendulum can be used in energy harvesting systems where periodic forces are used to extract energy. By tuning the system to resonate with the driving frequency, maximum energy transfer can occur. Suspension Bridges: In suspension bridges, oscillations can be driven by wind or traffic. The design must consider the possibility of resonance, which could lead to destructive oscillations. Oscillating Circuits: Driven RLC circuits, analogous to the forced damped pendulum, demonstrate similar behaviors. Engineers design circuits to avoid resonance to prevent excessive power consumption or damage. 4. Implementation In order to explore these behaviors computationally, a numerical simulation is required. A Python script or Jupyter notebook can be used to simulate the motion of the forced damped pendulum using methods like Runge-Kutta integration for solving the differential equation numerically. Numerical Methods The second-order differential equation can be transformed into a system of first-order differential equations: \\[ \\theta'(t) = v(t) \\] \\[ v'(t) = -2 \\gamma v(t) - \\omega_0^2 \\theta(t) + F_0 \\cos(\\omega t) \\] Using a method like the Runge-Kutta 4th order method , we can integrate these equations over time and observe the system's behavior under different conditions. Phase Diagrams and Poincar\u00e9 Sections Phase Diagram: Plot \\( \\theta(t) \\) vs. \\( v(t) \\) (angular velocity), which shows the system\u2019s trajectory in phase space. Poincar\u00e9 Section: A plot of the system's state at periodic intervals (e.g., every time the pendulum passes through the equilibrium position) to visualize the onset of chaotic behavior. Deliverables Markdown Document: A detailed explanation of the theory and solution for the forced damped pendulum. Discussion on resonance, chaotic behavior, and energy transfer. Python Code/Notebook: Python code to simulate the forced damped pendulum dynamics. Graphical representations of motion, including resonance and chaotic behavior. Visualizations: Phase diagrams and Poincar\u00e9 sections for different parameter settings (damping coefficient, driving amplitude, frequency). Discussion: Analysis of the limitations of the model, such as nonlinear damping, and suggestions for potential extensions (e.g., non-periodic forcing, multi-degree-of-freedom systems). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency of the pendulum F_0 = 1.0 # Driving force amplitude omega = 1.8 # Driving frequency t_span = (0, 50) # Time span for simulation (start, end) initial_conditions = [0.1, 0] # Initial conditions: [theta(0), omega(0)] # Define the system of differential equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -2 * gamma * omega - omega_0**2 * theta + F_0 * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solve the differential equation using the Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, initial_conditions, t_eval=np.linspace(t_span[0], t_span[1], 10000)) # Extract the solution time = sol.t theta = sol.y[0] omega = sol.y[1] # Plot the results # Plot Angular Displacement vs Time plt.figure(figsize=(12, 6)) plt.subplot(2, 2, 1) plt.plot(time, theta, label=\"Angular Displacement (theta)\") plt.title(\"Angular Displacement vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Theta [rad]\") plt.grid(True) # Plot Angular Velocity vs Time plt.subplot(2, 2, 2) plt.plot(time, omega, label=\"Angular Velocity (omega)\", color='orange') plt.title(\"Angular Velocity vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Phase Plot (theta vs omega) plt.subplot(2, 2, 3) plt.plot(theta, omega, label=\"Phase Plot\") plt.title(\"Phase Plot (Theta vs Omega)\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Poincar\u00e9 Section (plot at theta = 0) poincare_section = theta[theta[:-1] * theta[1:] < 0] poincare_omega = omega[:-1][theta[:-1] * theta[1:] < 0] plt.subplot(2, 2, 4) plt.plot(poincare_section, poincare_omega, 'o', label=\"Poincar\u00e9 Section\") plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Show the plots plt.tight_layout() plt.show()","title":"PROBLEM 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"PROBLEM 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#the-forced-damped-pendulum-model","text":"The motion of a forced damped pendulum can be described by the following second-order ordinary differential equation (ODE): \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) is the angular displacement of the pendulum as a function of time, \\( \\gamma \\) is the damping coefficient (representing the frictional or resistive forces), \\( \\omega_0 \\) is the natural frequency of the pendulum (which depends on the length and acceleration due to gravity), \\( F_0 \\) is the amplitude of the external driving force, \\( \\omega \\) is the driving angular frequency, and \\( t \\) is time. This equation describes the motion of the pendulum under the influence of both damping and an external periodic force. The term \\( 2 \\gamma \\theta'(t) \\) represents the damping force, \\( \\omega_0^2 \\theta(t) \\) represents the restoring force due to gravity, and \\( F_0 \\cos(\\omega t) \\) is the periodic driving force.","title":"The Forced Damped Pendulum Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we can assume that the angle \\( \\theta(t) \\) is small enough that \\( \\sin(\\theta(t)) \\approx \\theta(t) \\) , simplifying the equation of motion to: \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] This is a standard forced damped harmonic oscillator equation, which is more analytically tractable. The solution to this equation depends on several factors, including the damping coefficient, driving frequency, and driving amplitude.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solution-for-the-forced-damped-pendulum","text":"The general solution to the equation consists of two parts: Homogeneous Solution (related to the system's natural dynamics without the external force): $$ \\theta_h(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) $$ Where \\( A \\) and \\( \\phi \\) are constants determined by initial conditions, and the exponential decay factor \\( e^{-\\gamma t} \\) represents the damping of the system over time. Particular Solution (due to the external driving force): For a steady-state solution, we assume the system reaches a constant amplitude oscillation due to the external force. This solution can be written as: $$ \\theta_p(t) = B \\cos(\\omega t - \\delta) $$ Where \\( B \\) is the amplitude of oscillation and \\( \\delta \\) is the phase shift between the external force and the oscillation. Substituting this into the differential equation and solving for \\( B \\) and \\( \\delta \\) gives us the particular solution: $$ B = \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} $$ $$ \\delta = \\tan^{-1}\\left(\\frac{2 \\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right) $$ Thus, the complete solution to the equation is: \\[ \\theta(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) + \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} \\cos(\\omega t - \\delta) \\]","title":"Approximate Solution for the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions-and-energy-implications","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) of the pendulum. At resonance, the amplitude of oscillation \\( B \\) becomes large because the denominator in the expression for \\( B \\) becomes very small. In practice, resonance results in the system absorbing maximum energy from the external driving force. The energy absorbed by the system at resonance can be significant, and the oscillation amplitude grows, potentially leading to large motions. This behavior is especially important in engineering, where resonance must be avoided in structures like bridges and buildings to prevent catastrophic failure.","title":"Resonance Conditions and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-damping-coefficient-driving-amplitude-and-frequency","text":"Damping Coefficient ( \\( \\gamma \\) ): As \\( \\gamma \\) increases, the system's oscillations decay more rapidly, reducing the amplitude of oscillation. High damping can suppress resonance effects, limiting the system's ability to oscillate at high amplitudes. Driving Amplitude ( \\( F_0 \\) ): Increasing \\( F_0 \\) increases the amplitude of the system\u2019s steady-state oscillations. However, at very high \\( F_0 \\) , the system may exhibit nonlinear behavior, and the simple harmonic approximation may no longer be valid. Driving Frequency ( \\( \\omega \\) ): The driving frequency affects the resonance condition. If \\( \\omega \\) is close to \\( \\omega_0 \\) , resonance occurs, and the amplitude of oscillations becomes large. Away from resonance, the amplitude decreases.","title":"Influence of Damping Coefficient, Driving Amplitude, and Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-from-regular-to-chaotic-motion","text":"As the driving amplitude or frequency is varied, the system can transition from regular periodic oscillations to chaotic motion. This can be characterized by sensitivity to initial conditions, where small changes in initial displacement or velocity lead to dramatically different behavior over time. The transition to chaos can be studied using bifurcation diagrams and Poincar\u00e9 sections .","title":"Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting Devices: The forced damped pendulum can be used in energy harvesting systems where periodic forces are used to extract energy. By tuning the system to resonate with the driving frequency, maximum energy transfer can occur. Suspension Bridges: In suspension bridges, oscillations can be driven by wind or traffic. The design must consider the possibility of resonance, which could lead to destructive oscillations. Oscillating Circuits: Driven RLC circuits, analogous to the forced damped pendulum, demonstrate similar behaviors. Engineers design circuits to avoid resonance to prevent excessive power consumption or damage.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"In order to explore these behaviors computationally, a numerical simulation is required. A Python script or Jupyter notebook can be used to simulate the motion of the forced damped pendulum using methods like Runge-Kutta integration for solving the differential equation numerically.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-methods","text":"The second-order differential equation can be transformed into a system of first-order differential equations: \\[ \\theta'(t) = v(t) \\] \\[ v'(t) = -2 \\gamma v(t) - \\omega_0^2 \\theta(t) + F_0 \\cos(\\omega t) \\] Using a method like the Runge-Kutta 4th order method , we can integrate these equations over time and observe the system's behavior under different conditions.","title":"Numerical Methods"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagrams-and-poincare-sections","text":"Phase Diagram: Plot \\( \\theta(t) \\) vs. \\( v(t) \\) (angular velocity), which shows the system\u2019s trajectory in phase space. Poincar\u00e9 Section: A plot of the system's state at periodic intervals (e.g., every time the pendulum passes through the equilibrium position) to visualize the onset of chaotic behavior.","title":"Phase Diagrams and Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"Markdown Document: A detailed explanation of the theory and solution for the forced damped pendulum. Discussion on resonance, chaotic behavior, and energy transfer. Python Code/Notebook: Python code to simulate the forced damped pendulum dynamics. Graphical representations of motion, including resonance and chaotic behavior. Visualizations: Phase diagrams and Poincar\u00e9 sections for different parameter settings (damping coefficient, driving amplitude, frequency). Discussion: Analysis of the limitations of the model, such as nonlinear damping, and suggestions for potential extensions (e.g., non-periodic forcing, multi-degree-of-freedom systems). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency of the pendulum F_0 = 1.0 # Driving force amplitude omega = 1.8 # Driving frequency t_span = (0, 50) # Time span for simulation (start, end) initial_conditions = [0.1, 0] # Initial conditions: [theta(0), omega(0)] # Define the system of differential equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -2 * gamma * omega - omega_0**2 * theta + F_0 * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solve the differential equation using the Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, initial_conditions, t_eval=np.linspace(t_span[0], t_span[1], 10000)) # Extract the solution time = sol.t theta = sol.y[0] omega = sol.y[1] # Plot the results # Plot Angular Displacement vs Time plt.figure(figsize=(12, 6)) plt.subplot(2, 2, 1) plt.plot(time, theta, label=\"Angular Displacement (theta)\") plt.title(\"Angular Displacement vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Theta [rad]\") plt.grid(True) # Plot Angular Velocity vs Time plt.subplot(2, 2, 2) plt.plot(time, omega, label=\"Angular Velocity (omega)\", color='orange') plt.title(\"Angular Velocity vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Phase Plot (theta vs omega) plt.subplot(2, 2, 3) plt.plot(theta, omega, label=\"Phase Plot\") plt.title(\"Phase Plot (Theta vs Omega)\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Poincar\u00e9 Section (plot at theta = 0) poincare_section = theta[theta[:-1] * theta[1:] < 0] poincare_omega = omega[:-1][theta[:-1] * theta[1:] < 0] plt.subplot(2, 2, 4) plt.plot(poincare_section, poincare_omega, 'o', label=\"Poincar\u00e9 Section\") plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Show the plots plt.tight_layout() plt.show()","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius: A Manual Motivation Kepler's Third Law states that the square of a planet's orbital period (T) is proportional to the cube of its orbital radius (R): \\[ T^2 \\propto R^3 \\] This law helps determine planetary motions, celestial masses, and gravitational interactions across different astronomical systems. Derivation of Kepler's Third Law For a circular orbit, the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v^2}{R} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{R} \\] Expressing velocity in terms of the orbital period: \\[ v = \\frac{2 \\pi R}{T} \\Rightarrow \\frac{4 \\pi^2 R^2}{T^2} = \\frac{G M}{R} \\] Rearranging: \\[ T^2 = \\frac{4 \\pi^2 R^3}{G M} \\] This confirms that \\( T^2 \\) is proportional to \\( R^3 \\) . Implications in Astronomy Mass Calculation : Used to determine the mass of stars and planets. Satellite Orbits : Governs artificial and natural satellite motion. Binary Systems : Helps estimate masses of orbiting stars. Real-World Examples Earth\u2019s Orbit Around the Sun \\( R = 1.496 \\times 10^{11} \\) m, \\( T \\approx 365.25 \\) days Verifies the Sun\u2019s mass using Kepler\u2019s Law. Moon\u2019s Orbit Around Earth \\( R = 3.844 \\times 10^8 \\) m, \\( T = 27.3 \\) days Determines Earth\u2019s mass from lunar motion. Graphical Representation Plot of \\( T^2 \\) vs. \\( R^3 \\) : Confirms linear proportionality. Orbit Simulation : Visualizes circular orbital motion. Extension to Elliptical Orbits For elliptical orbits, the semi-major axis \\( a \\) replaces \\( R \\) : \\[ T^2 \\propto a^3 \\] This applies to comets, exoplanets, and non-circular orbits. Conclusion Kepler\u2019s Third Law is fundamental in celestial mechanics, enabling: Prediction of planetary positions, Calculation of celestial masses, Design of satellite trajectories. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # Astronomical Unit in meters def orbital_period(R, M): \"\"\"Calculate the orbital period using Kepler's Third Law.\"\"\" return np.sqrt((4 * np.pi**2 * R**3) / (G * M)) # Define a range of orbital radii (multiples of AU) orbital_radii = np.linspace(0.1, 5, 50) * AU orbital_periods = orbital_period(orbital_radii, M_sun) # Compute square of periods and cube of radii T_squared = orbital_periods**2 R_cubed = orbital_radii**3 # Plot T^2 vs. R^3 to validate Kepler's Third Law plt.figure(figsize=(8, 6)) plt.plot(R_cubed, T_squared, 'bo-', label='Simulated Data') plt.xlabel(\"Orbital Radius Cubed (R\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared (T\u00b2) [s\u00b2]\") plt.title(\"Kepler's Third Law: T\u00b2 vs R\u00b3\") plt.legend() plt.grid() plt.show() # Additional plot: Log-Log scale to show proportionality plt.figure(figsize=(8, 6)) plt.loglog(R_cubed, T_squared, 'ro-', label='Log-Log Relationship') plt.xlabel(\"log(R\u00b3)\") plt.ylabel(\"log(T\u00b2)\") plt.title(\"Kepler's Third Law in Log Scale\") plt.legend() plt.grid(True, which=\"both\", linestyle=\"--\") plt.show() def plot_orbit(radius, title=\"Circular Orbit\"): \"\"\"Simulate and plot a circular orbit.\"\"\" theta = np.linspace(0, 2*np.pi, 100) x = radius * np.cos(theta) y = radius * np.sin(theta) lt text\" style=\"width: 300px; height: 200px;\"> plt.figure(figsize=(6, 6)) plt.plot(x, y, 'b-', label='Orbital Path') plt.plot(0, 0, 'yo', markersize=10, label='Central Body') plt.xlabel(\"X Position [m]\") plt.ylabel(\"Y Position [m]\") plt.title(title) plt.legend() plt.grid() plt.axis('equal') plt.show() # Simulate Earth's orbit around the Sun plot_orbit(AU, \"Earth's Orbit Around the Sun\") # Simulate a smaller orbit for comparison plot_orbit(0.5 * AU, \"Smaller Orbit (0.5 AU Radius)\") # Simulate a larger orbit for further comparison plot_orbit(2 * AU, \"Larger Orbit (2 AU Radius)\") # Python Code Example","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-a-manual","text":"","title":"Orbital Period and Orbital Radius: A Manual"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of a planet's orbital period (T) is proportional to the cube of its orbital radius (R): \\[ T^2 \\propto R^3 \\] This law helps determine planetary motions, celestial masses, and gravitational interactions across different astronomical systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a circular orbit, the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v^2}{R} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{R} \\] Expressing velocity in terms of the orbital period: \\[ v = \\frac{2 \\pi R}{T} \\Rightarrow \\frac{4 \\pi^2 R^2}{T^2} = \\frac{G M}{R} \\] Rearranging: \\[ T^2 = \\frac{4 \\pi^2 R^3}{G M} \\] This confirms that \\( T^2 \\) is proportional to \\( R^3 \\) .","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Mass Calculation : Used to determine the mass of stars and planets. Satellite Orbits : Governs artificial and natural satellite motion. Binary Systems : Helps estimate masses of orbiting stars.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#earths-orbit-around-the-sun","text":"\\( R = 1.496 \\times 10^{11} \\) m, \\( T \\approx 365.25 \\) days Verifies the Sun\u2019s mass using Kepler\u2019s Law.","title":"Earth\u2019s Orbit Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth","text":"\\( R = 3.844 \\times 10^8 \\) m, \\( T = 27.3 \\) days Determines Earth\u2019s mass from lunar motion.","title":"Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-representation","text":"Plot of \\( T^2 \\) vs. \\( R^3 \\) : Confirms linear proportionality. Orbit Simulation : Visualizes circular orbital motion.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, the semi-major axis \\( a \\) replaces \\( R \\) : \\[ T^2 \\propto a^3 \\] This applies to comets, exoplanets, and non-circular orbits.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law is fundamental in celestial mechanics, enabling: Prediction of planetary positions, Calculation of celestial masses, Design of satellite trajectories. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # Astronomical Unit in meters def orbital_period(R, M): \"\"\"Calculate the orbital period using Kepler's Third Law.\"\"\" return np.sqrt((4 * np.pi**2 * R**3) / (G * M)) # Define a range of orbital radii (multiples of AU) orbital_radii = np.linspace(0.1, 5, 50) * AU orbital_periods = orbital_period(orbital_radii, M_sun) # Compute square of periods and cube of radii T_squared = orbital_periods**2 R_cubed = orbital_radii**3 # Plot T^2 vs. R^3 to validate Kepler's Third Law plt.figure(figsize=(8, 6)) plt.plot(R_cubed, T_squared, 'bo-', label='Simulated Data') plt.xlabel(\"Orbital Radius Cubed (R\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared (T\u00b2) [s\u00b2]\") plt.title(\"Kepler's Third Law: T\u00b2 vs R\u00b3\") plt.legend() plt.grid() plt.show() # Additional plot: Log-Log scale to show proportionality plt.figure(figsize=(8, 6)) plt.loglog(R_cubed, T_squared, 'ro-', label='Log-Log Relationship') plt.xlabel(\"log(R\u00b3)\") plt.ylabel(\"log(T\u00b2)\") plt.title(\"Kepler's Third Law in Log Scale\") plt.legend() plt.grid(True, which=\"both\", linestyle=\"--\") plt.show() def plot_orbit(radius, title=\"Circular Orbit\"): \"\"\"Simulate and plot a circular orbit.\"\"\" theta = np.linspace(0, 2*np.pi, 100) x = radius * np.cos(theta) y = radius * np.sin(theta) lt text\" style=\"width: 300px; height: 200px;\"> plt.figure(figsize=(6, 6)) plt.plot(x, y, 'b-', label='Orbital Path') plt.plot(0, 0, 'yo', markersize=10, label='Central Body') plt.xlabel(\"X Position [m]\") plt.ylabel(\"Y Position [m]\") plt.title(title) plt.legend() plt.grid() plt.axis('equal') plt.show() # Simulate Earth's orbit around the Sun plot_orbit(AU, \"Earth's Orbit Around the Sun\") # Simulate a smaller orbit for comparison plot_orbit(0.5 * AU, \"Smaller Orbit (0.5 AU Radius)\") # Simulate a larger orbit for further comparison plot_orbit(2 * AU, \"Larger Orbit (2 AU Radius)\") # Python Code Example","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities and Escape Velocities Introduction The concept of escape velocity is fundamental in understanding how an object can overcome the gravitational pull of a celestial body, such as Earth or Mars. Beyond escape velocity, there are different thresholds of velocity required to achieve different types of orbits or escape trajectories within a star system. These thresholds are called cosmic velocities . Cosmic Velocities The first, second, and third cosmic velocities define the following: 1. First Cosmic Velocity (Orbital Velocity) This is the velocity required for an object to enter a stable orbit around a celestial body, such as Earth. It is also known as the orbital velocity . An object traveling at this speed will move in a circular orbit at a constant distance from the body\u2019s center. 2. Second Cosmic Velocity (Escape Velocity) This is the velocity required to escape the gravitational influence of the celestial body entirely. This velocity allows an object to break free from the gravitational pull of the body and not return. It is also known as the escape velocity . 3. Third Cosmic Velocity (Escape from the Solar System) This is the velocity required for an object to escape the gravitational influence of the Sun (or any other star) and travel into interstellar space. It is the velocity needed to leave the gravitational influence of a star system entirely. Derivations and Mathematical Foundations The velocities described above are derived using the concept of gravitational potential energy and kinetic energy. The basic formula for gravitational potential energy is: \\[ U = - \\frac{GMm}{r} \\] Where: \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) ), \\( M \\) is the mass of the celestial body, \\( m \\) is the mass of the object, \\( r \\) is the distance from the center of the celestial body. The kinetic energy of an object in motion is given by: \\[ K = \\frac{1}{2} mv^2 \\] Where \\( v \\) is the velocity of the object. 1. First Cosmic Velocity (Orbital Velocity) To find the first cosmic velocity, we balance the centripetal force (required for circular motion) with the gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying, the orbital velocity \\( v_1 \\) is: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity (Escape Velocity) For escape velocity, the total mechanical energy (kinetic + potential) must be zero for the object to escape the gravitational pull. The escape velocity \\( v_2 \\) is derived by setting the total energy equal to zero: \\[ \\frac{1}{2} mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\( v_2 \\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity (Velocity to Escape the Sun's Gravitational Influence) The third cosmic velocity is the speed required to escape the Sun's gravity. Assuming the object is at the Earth-Sun distance (1 AU), the formula is: \\[ v_3 = \\sqrt{2GM_{\\text{sun}} \\left( \\frac{1}{r_{\\text{sun}}} - \\frac{1}{r_{\\text{Earth}}} \\right)} \\] Where: \\( M\\_{\\text{sun}} \\) is the mass of the Sun, \\( r\\_{\\text{sun}} \\) is the Sun\u2019s radius, \\( r\\_{\\text{Earth}} \\) is the Earth\u2019s distance from the Sun. Parameters Affecting These Velocities The velocities depend primarily on: The mass ( \\( M \\) ) of the celestial body (for first and second cosmic velocities), The radius ( \\( r \\) ) of the celestial body or the distance from the body (for all cosmic velocities), The gravitational constant \\( G \\) , which remains the same universally, The mass of the Sun for third cosmic velocity, and the Earth's distance from the Sun for its calculation. The greater the mass of the celestial body and the smaller the radius, the higher the velocities required. Cosmic Velocities for Different Celestial Bodies Let's now calculate the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Parameters for Calculation Earth: \\( M\\_{\\text{Earth}} = 5.972 \\times 10^{24} \\, \\text{kg} \\) \\( r\\_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m} \\) \\( r\\_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\, \\text{m} \\) (distance from Sun) Mars: \\( M\\_{\\text{Mars}} = 6.417 \\times 10^{23} \\, \\text{kg} \\) \\( r\\_{\\text{Mars}} = 3.396 \\times 10^6 \\, \\text{m} \\) Jupiter: \\( M\\_{\\text{Jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg} \\) \\( r\\_{\\text{Jupiter}} = 6.991 \\times 10^7 \\, \\text{m} \\) Now we will calculate the first and second cosmic velocities for these celestial bodies. The third cosmic velocity requires the mass of the Sun and the distances from the Sun, which we can compute for each planet's position. Python Code for Calculation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # mass of the Sun in kg # Function to calculate escape velocity (second cosmic velocity) def escape_velocity(M, r): \"\"\" Calculate escape velocity (second cosmic velocity) \"\"\" return np.sqrt(2 * G * M / r) # Function to calculate orbital velocity (first cosmic velocity) def orbital_velocity(M, r): \"\"\" Calculate orbital velocity (first cosmic velocity) \"\"\" return np.sqrt(G * M / r) # Function to calculate third cosmic velocity (escape from Sun's gravitational influence) def third_cosmic_velocity(distance_from_sun): \"\"\" Calculate third cosmic velocity (escape velocity from Sun) \"\"\" return np.sqrt(2 * G * M_sun * (1 / distance_from_sun)) # Function to calculate velocities for a set of planets def calculate_planetary_velocities(planets): velocities = {} for planet, data in planets.items(): M, r, distance_from_sun = data[\"M\"], data[\"r\"], data[\"distance_from_sun\"] v1 = orbital_velocity(M, r) # First cosmic velocity v2 = escape_velocity(M, r) # Second cosmic velocity v3 = third_cosmic_velocity(distance_from_sun) # Third cosmic velocity velocities[planet] = {'v1': v1, 'v2': v2, 'v3': v3} return velocities # Function to print velocities def print_velocities(velocities): for planet, velocity in velocities.items(): print(f\"Velocities for {planet}:\") print(f\"First Cosmic Velocity (Orbital): {velocity['v1'] / 1000:.2f} km/s\") print(f\"Second Cosmic Velocity (Escape): {velocity['v2'] / 1000:.2f} km/s\") print(f\"Third Cosmic Velocity: {velocity['v3'] / 1000:.2f} km/s\") print() # Function to plot cosmic velocities def plot_cosmic_velocities(velocities): # Extract velocities for plotting planet_names = list(velocities.keys()) v1_vals = [velocities[planet]['v1'] / 1000 for planet in planet_names] # Convert m/s to km/s v2_vals = [velocities[planet]['v2'] / 1000 for planet in planet_names] # Convert m/s to km/s v3_vals = [velocities[planet]['v3'] / 1000 for planet in planet_names] # Convert m/s to km/s # Plotting: Bar plot to show the first, second, and third cosmic velocities plt.figure(figsize=(12, 6)) width = 0.25 # Width of the bars x = np.arange(len(planet_names)) plt.bar(x - width, v1_vals, width, label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.bar(x, v2_vals, width, label=\"Second Cosmic Velocity (Escape)\", color='green') plt.bar(x + width, v3_vals, width, label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xlabel('Planets') plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities for Different Planets') plt.xticks(x, planet_names) plt.legend() plt.tight_layout() plt.show() # Function to plot detailed line plot for cosmic velocities across distances def plot_cosmic_velocities_across_distances(): distances = np.logspace(6, 12, num=100) # Log space for distances, ranging from 10^6 to 10^12 meters planetary_velocities = {'First Cosmic': [], 'Second Cosmic': [], 'Third Cosmic': []} for r in distances: # Calculate the first cosmic velocity for a given distance (orbital velocity) v1 = orbital_velocity(M_sun, r) # Using the mass of the Sun for simplicity planetary_velocities['First Cosmic'].append(v1 / 1000) # Convert to km/s # Calculate the second cosmic velocity for a given distance (escape velocity) v2 = escape_velocity(M_sun, r) # Using the mass of the Sun for escape velocity planetary_velocities['Second Cosmic'].append(v2 / 1000) # Convert to km/s # Calculate the third cosmic velocity for a given distance from the Sun v3 = third_cosmic_velocity(r) planetary_velocities['Third Cosmic'].append(v3 / 1000) # Convert to km/s # Plotting line graph of cosmic velocities as a function of distance plt.figure(figsize=(12, 6)) plt.plot(distances, planetary_velocities['First Cosmic'], label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.plot(distances, planetary_velocities['Second Cosmic'], label=\"Second Cosmic Velocity (Escape)\", color='green') plt.plot(distances, planetary_velocities['Third Cosmic'], label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xscale('log') plt.yscale('log') plt.xlabel('Distance from the center (m)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities as a Function of Distance') plt.legend() plt.tight_layout() plt.show() # Planetary data: (mass in kg, radius in meters, distance from Sun in meters) planets = { \"Earth\": { \"M\": 5.972e24, \"r\": 6.371e6, \"distance_from_sun\": 1.496e11 }, \"Mars\": { \"M\": 6.417e23, \"r\": 3.396e6, \"distance_from_sun\": 2.279e11 }, \"Jupiter\": { \"M\": 1.898e27, \"r\": 6.991e7, \"distance_from_sun\": 7.783e11 } } # Calculate velocities for each planet velocities = calculate_planetary_velocities(planets) # Output the velocities print_velocities(velocities) # Plot the velocities plot_cosmic_velocities(velocities) # Plot the cosmic velocities across distances plot_cosmic_velocities_across_distances()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-and-escape-velocities","text":"","title":"Cosmic Velocities and Escape Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is fundamental in understanding how an object can overcome the gravitational pull of a celestial body, such as Earth or Mars. Beyond escape velocity, there are different thresholds of velocity required to achieve different types of orbits or escape trajectories within a star system. These thresholds are called cosmic velocities .","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities","text":"The first, second, and third cosmic velocities define the following:","title":"Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"This is the velocity required for an object to enter a stable orbit around a celestial body, such as Earth. It is also known as the orbital velocity . An object traveling at this speed will move in a circular orbit at a constant distance from the body\u2019s center.","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"This is the velocity required to escape the gravitational influence of the celestial body entirely. This velocity allows an object to break free from the gravitational pull of the body and not return. It is also known as the escape velocity .","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-escape-from-the-solar-system","text":"This is the velocity required for an object to escape the gravitational influence of the Sun (or any other star) and travel into interstellar space. It is the velocity needed to leave the gravitational influence of a star system entirely.","title":"3. Third Cosmic Velocity (Escape from the Solar System)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations-and-mathematical-foundations","text":"The velocities described above are derived using the concept of gravitational potential energy and kinetic energy. The basic formula for gravitational potential energy is: \\[ U = - \\frac{GMm}{r} \\] Where: \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) ), \\( M \\) is the mass of the celestial body, \\( m \\) is the mass of the object, \\( r \\) is the distance from the center of the celestial body. The kinetic energy of an object in motion is given by: \\[ K = \\frac{1}{2} mv^2 \\] Where \\( v \\) is the velocity of the object.","title":"Derivations and Mathematical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity_1","text":"To find the first cosmic velocity, we balance the centripetal force (required for circular motion) with the gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying, the orbital velocity \\( v_1 \\) is: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity_1","text":"For escape velocity, the total mechanical energy (kinetic + potential) must be zero for the object to escape the gravitational pull. The escape velocity \\( v_2 \\) is derived by setting the total energy equal to zero: \\[ \\frac{1}{2} mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\( v_2 \\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-velocity-to-escape-the-suns-gravitational-influence","text":"The third cosmic velocity is the speed required to escape the Sun's gravity. Assuming the object is at the Earth-Sun distance (1 AU), the formula is: \\[ v_3 = \\sqrt{2GM_{\\text{sun}} \\left( \\frac{1}{r_{\\text{sun}}} - \\frac{1}{r_{\\text{Earth}}} \\right)} \\] Where: \\( M\\_{\\text{sun}} \\) is the mass of the Sun, \\( r\\_{\\text{sun}} \\) is the Sun\u2019s radius, \\( r\\_{\\text{Earth}} \\) is the Earth\u2019s distance from the Sun.","title":"3. Third Cosmic Velocity (Velocity to Escape the Sun's Gravitational Influence)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-affecting-these-velocities","text":"The velocities depend primarily on: The mass ( \\( M \\) ) of the celestial body (for first and second cosmic velocities), The radius ( \\( r \\) ) of the celestial body or the distance from the body (for all cosmic velocities), The gravitational constant \\( G \\) , which remains the same universally, The mass of the Sun for third cosmic velocity, and the Earth's distance from the Sun for its calculation. The greater the mass of the celestial body and the smaller the radius, the higher the velocities required.","title":"Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-for-different-celestial-bodies","text":"Let's now calculate the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-for-calculation","text":"","title":"Parameters for Calculation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\( M\\_{\\text{Earth}} = 5.972 \\times 10^{24} \\, \\text{kg} \\) \\( r\\_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m} \\) \\( r\\_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\, \\text{m} \\) (distance from Sun)","title":"Earth:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"\\( M\\_{\\text{Mars}} = 6.417 \\times 10^{23} \\, \\text{kg} \\) \\( r\\_{\\text{Mars}} = 3.396 \\times 10^6 \\, \\text{m} \\)","title":"Mars:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"\\( M\\_{\\text{Jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg} \\) \\( r\\_{\\text{Jupiter}} = 6.991 \\times 10^7 \\, \\text{m} \\) Now we will calculate the first and second cosmic velocities for these celestial bodies. The third cosmic velocity requires the mass of the Sun and the distances from the Sun, which we can compute for each planet's position.","title":"Jupiter:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-calculation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # mass of the Sun in kg # Function to calculate escape velocity (second cosmic velocity) def escape_velocity(M, r): \"\"\" Calculate escape velocity (second cosmic velocity) \"\"\" return np.sqrt(2 * G * M / r) # Function to calculate orbital velocity (first cosmic velocity) def orbital_velocity(M, r): \"\"\" Calculate orbital velocity (first cosmic velocity) \"\"\" return np.sqrt(G * M / r) # Function to calculate third cosmic velocity (escape from Sun's gravitational influence) def third_cosmic_velocity(distance_from_sun): \"\"\" Calculate third cosmic velocity (escape velocity from Sun) \"\"\" return np.sqrt(2 * G * M_sun * (1 / distance_from_sun)) # Function to calculate velocities for a set of planets def calculate_planetary_velocities(planets): velocities = {} for planet, data in planets.items(): M, r, distance_from_sun = data[\"M\"], data[\"r\"], data[\"distance_from_sun\"] v1 = orbital_velocity(M, r) # First cosmic velocity v2 = escape_velocity(M, r) # Second cosmic velocity v3 = third_cosmic_velocity(distance_from_sun) # Third cosmic velocity velocities[planet] = {'v1': v1, 'v2': v2, 'v3': v3} return velocities # Function to print velocities def print_velocities(velocities): for planet, velocity in velocities.items(): print(f\"Velocities for {planet}:\") print(f\"First Cosmic Velocity (Orbital): {velocity['v1'] / 1000:.2f} km/s\") print(f\"Second Cosmic Velocity (Escape): {velocity['v2'] / 1000:.2f} km/s\") print(f\"Third Cosmic Velocity: {velocity['v3'] / 1000:.2f} km/s\") print() # Function to plot cosmic velocities def plot_cosmic_velocities(velocities): # Extract velocities for plotting planet_names = list(velocities.keys()) v1_vals = [velocities[planet]['v1'] / 1000 for planet in planet_names] # Convert m/s to km/s v2_vals = [velocities[planet]['v2'] / 1000 for planet in planet_names] # Convert m/s to km/s v3_vals = [velocities[planet]['v3'] / 1000 for planet in planet_names] # Convert m/s to km/s # Plotting: Bar plot to show the first, second, and third cosmic velocities plt.figure(figsize=(12, 6)) width = 0.25 # Width of the bars x = np.arange(len(planet_names)) plt.bar(x - width, v1_vals, width, label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.bar(x, v2_vals, width, label=\"Second Cosmic Velocity (Escape)\", color='green') plt.bar(x + width, v3_vals, width, label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xlabel('Planets') plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities for Different Planets') plt.xticks(x, planet_names) plt.legend() plt.tight_layout() plt.show() # Function to plot detailed line plot for cosmic velocities across distances def plot_cosmic_velocities_across_distances(): distances = np.logspace(6, 12, num=100) # Log space for distances, ranging from 10^6 to 10^12 meters planetary_velocities = {'First Cosmic': [], 'Second Cosmic': [], 'Third Cosmic': []} for r in distances: # Calculate the first cosmic velocity for a given distance (orbital velocity) v1 = orbital_velocity(M_sun, r) # Using the mass of the Sun for simplicity planetary_velocities['First Cosmic'].append(v1 / 1000) # Convert to km/s # Calculate the second cosmic velocity for a given distance (escape velocity) v2 = escape_velocity(M_sun, r) # Using the mass of the Sun for escape velocity planetary_velocities['Second Cosmic'].append(v2 / 1000) # Convert to km/s # Calculate the third cosmic velocity for a given distance from the Sun v3 = third_cosmic_velocity(r) planetary_velocities['Third Cosmic'].append(v3 / 1000) # Convert to km/s # Plotting line graph of cosmic velocities as a function of distance plt.figure(figsize=(12, 6)) plt.plot(distances, planetary_velocities['First Cosmic'], label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.plot(distances, planetary_velocities['Second Cosmic'], label=\"Second Cosmic Velocity (Escape)\", color='green') plt.plot(distances, planetary_velocities['Third Cosmic'], label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xscale('log') plt.yscale('log') plt.xlabel('Distance from the center (m)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities as a Function of Distance') plt.legend() plt.tight_layout() plt.show() # Planetary data: (mass in kg, radius in meters, distance from Sun in meters) planets = { \"Earth\": { \"M\": 5.972e24, \"r\": 6.371e6, \"distance_from_sun\": 1.496e11 }, \"Mars\": { \"M\": 6.417e23, \"r\": 3.396e6, \"distance_from_sun\": 2.279e11 }, \"Jupiter\": { \"M\": 1.898e27, \"r\": 6.991e7, \"distance_from_sun\": 7.783e11 } } # Calculate velocities for each planet velocities = calculate_planetary_velocities(planets) # Output the velocities print_velocities(velocities) # Plot the velocities plot_cosmic_velocities(velocities) # Plot the cosmic velocities across distances plot_cosmic_velocities_across_distances()","title":"Python Code for Calculation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 1. Introduction to Trajectories Near Earth When a payload is released near Earth from a moving rocket, its trajectory depends on several factors: Initial Position : The starting point of the payload relative to Earth. Initial Velocity : The speed and direction of the payload when released. Gravitational Forces : The Earth\u2019s gravitational field acting on the payload. Orbital Mechanics Principles : Newton\u2019s Law of Gravitation, Kepler\u2019s Laws, and the concepts of escape velocity and orbital insertion. 2. Orbital Mechanics Fundamentals Gravitational Force According to Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: \\( F \\) is the gravitational force. \\( G \\) is the gravitational constant. \\( M \\) is the mass of Earth. \\( m \\) is the mass of the payload. \\( r \\) is the distance between the center of the Earth and the payload. Equations of Motion The motion of the payload is governed by Newton's second law, where the gravitational force provides the acceleration: \\[ F = ma = \\frac{GMm}{r^2} \\hat{r} \\] This leads to the second-order differential equations that describe the position and velocity of the payload over time. These equations are usually solved numerically because they involve non-linear terms due to the \\( r^2 \\) dependence in the gravitational force. Escape Velocity The escape velocity is the minimum speed needed for an object to escape Earth's gravitational field, and it can be computed using: \\[ v_e = \\sqrt{\\frac{2GM}{r}} \\] Where: \\( v_e \\) is the escape velocity. \\( r \\) is the distance from the center of Earth. Orbital Types Based on the velocity of the object relative to Earth's gravity, the trajectory can be: Elliptical : If the object's velocity is less than the escape velocity. Parabolic : If the velocity is exactly equal to the escape velocity. Hyperbolic : If the object's velocity is greater than the escape velocity. 3. Numerical Simulation Approach We\u2019ll use Python to implement the simulation. The goal is to numerically solve the equations of motion for a payload under Earth\u2019s gravitational field. 3.1 Initial Setup We'll assume the following initial conditions for simplicity: Initial position \\( r_0 = (x_0, y_0, z_0) \\) . Initial velocity \\( v_0 = (v_x, v_y, v_z) \\) . Earth's gravitational constant \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) . Earth's mass \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) . Earth's radius \\( R = 6371 \\, \\text{km} \\) . 3.2 Solving the Equations of Motion We\u2019ll solve the following system of equations numerically: \\[ r''(t) = -\\frac{GM}{|r(t)|^3} r(t) \\] This requires discretizing time and numerically solving for the position and velocity at each timestep using a numerical integrator like Runge-Kutta or Euler's method. 3.3 Visualization We will visualize the trajectory using matplotlib in Python, creating plots that show the path of the payload, its velocity vector, and the Earth\u2019s gravitational influence. 4. Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371e3 # Radius of Earth (m) # Function to compute the gravitational force and acceleration def gravitational_acceleration(r): r_magnitude = np.linalg.norm(r) return -G * M * r / r_magnitude**3 # Function to compute escape velocity at a given distance from Earth's center def escape_velocity(r): return np.sqrt(2 * G * M / r) # Initial conditions (different cases for initial velocity) initial_conditions = [ (np.array([7000e3, 0, 0]), np.array([0, 7.12e3, 0])), # Elliptical (less than escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 11.2e3, 0])), # Parabolic (exactly escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 15e3, 0])), # Hyperbolic (greater than escape velocity) ] # Time parameters t_max = 6000 # Maximum time (s) dt = 1 # Time step (s) times = np.arange(0, t_max, dt) # Plot setup fig, ax = plt.subplots(2, 2, figsize=(14, 12)) # Initialize plot styles colors = ['blue', 'green', 'red'] labels = ['Elliptical Trajectory', 'Parabolic Trajectory', 'Hyperbolic Trajectory'] # Loop over different initial conditions to simulate trajectories for i, (r0, v0) in enumerate(initial_conditions): # Initialize arrays to store results positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot trajectory in the first subplot (showing different types) ax[0, 0].plot(positions[:, 0] / 1000, positions[:, 1] / 1000, label=labels[i], color=colors[i]) # Add labels and Earth marker ax[0, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[0, 0].set_title('Orbital Trajectories Near Earth') ax[0, 0].set_xlabel('X Position (km)') ax[0, 0].set_ylabel('Y Position (km)') ax[0, 0].grid(True) ax[0, 0].legend() # Plot escape velocity as a function of distance from Earth's center (second subplot) r_vals = np.linspace(R, 5e7, 100) # from Earth's surface to 50,000 km away v_escape = escape_velocity(r_vals) ax[0, 1].plot(r_vals / 1000, v_escape / 1000, color='purple') ax[0, 1].set_title('Escape Velocity vs. Distance from Earth') ax[0, 1].set_xlabel('Distance from Earth Center (km)') ax[0, 1].set_ylabel('Escape Velocity (km/s)') ax[0, 1].grid(True) # Plot the velocity vectors for different positions (third subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot velocity vectors ax[1, 0].quiver(positions[::100, 0] / 1000, positions[::100, 1] / 1000, velocities[::100, 0] / 1000, velocities[::100, 1] / 1000, angles='xy', scale_units='xy', scale=0.1, color=colors[i], label=labels[i]) ax[1, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[1, 0].set_title('Velocity Vectors of Payloads') ax[1, 0].set_xlabel('X Position (km)') ax[1, 0].set_ylabel('Y Position (km)') ax[1, 0].legend() ax[1, 0].grid(True) # Plot position vs time for all three scenarios (fourth subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot position vs time (radial distance) radial_distance = np.linalg.norm(positions, axis=1) / 1000 # in km ax[1, 1].plot(times / 60, radial_distance, label=labels[i], color=colors[i]) ax[1, 1].set_title('Radial Distance vs Time') ax[1, 1].set_xlabel('Time (minutes)') ax[1, 1].set_ylabel('Radial Distance (km)') ax[1, 1].legend() ax[1, 1].grid(True) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-to-trajectories-near-earth","text":"When a payload is released near Earth from a moving rocket, its trajectory depends on several factors: Initial Position : The starting point of the payload relative to Earth. Initial Velocity : The speed and direction of the payload when released. Gravitational Forces : The Earth\u2019s gravitational field acting on the payload. Orbital Mechanics Principles : Newton\u2019s Law of Gravitation, Kepler\u2019s Laws, and the concepts of escape velocity and orbital insertion.","title":"1. Introduction to Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-orbital-mechanics-fundamentals","text":"","title":"2. Orbital Mechanics Fundamentals"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-force","text":"According to Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: \\( F \\) is the gravitational force. \\( G \\) is the gravitational constant. \\( M \\) is the mass of Earth. \\( m \\) is the mass of the payload. \\( r \\) is the distance between the center of the Earth and the payload.","title":"Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload is governed by Newton's second law, where the gravitational force provides the acceleration: \\[ F = ma = \\frac{GMm}{r^2} \\hat{r} \\] This leads to the second-order differential equations that describe the position and velocity of the payload over time. These equations are usually solved numerically because they involve non-linear terms due to the \\( r^2 \\) dependence in the gravitational force.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity is the minimum speed needed for an object to escape Earth's gravitational field, and it can be computed using: \\[ v_e = \\sqrt{\\frac{2GM}{r}} \\] Where: \\( v_e \\) is the escape velocity. \\( r \\) is the distance from the center of Earth.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-types","text":"Based on the velocity of the object relative to Earth's gravity, the trajectory can be: Elliptical : If the object's velocity is less than the escape velocity. Parabolic : If the velocity is exactly equal to the escape velocity. Hyperbolic : If the object's velocity is greater than the escape velocity.","title":"Orbital Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation-approach","text":"We\u2019ll use Python to implement the simulation. The goal is to numerically solve the equations of motion for a payload under Earth\u2019s gravitational field.","title":"3. Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#31-initial-setup","text":"We'll assume the following initial conditions for simplicity: Initial position \\( r_0 = (x_0, y_0, z_0) \\) . Initial velocity \\( v_0 = (v_x, v_y, v_z) \\) . Earth's gravitational constant \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) . Earth's mass \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) . Earth's radius \\( R = 6371 \\, \\text{km} \\) .","title":"3.1 Initial Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#32-solving-the-equations-of-motion","text":"We\u2019ll solve the following system of equations numerically: \\[ r''(t) = -\\frac{GM}{|r(t)|^3} r(t) \\] This requires discretizing time and numerically solving for the position and velocity at each timestep using a numerical integrator like Runge-Kutta or Euler's method.","title":"3.2 Solving the Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#33-visualization","text":"We will visualize the trajectory using matplotlib in Python, creating plots that show the path of the payload, its velocity vector, and the Earth\u2019s gravitational influence.","title":"3.3 Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371e3 # Radius of Earth (m) # Function to compute the gravitational force and acceleration def gravitational_acceleration(r): r_magnitude = np.linalg.norm(r) return -G * M * r / r_magnitude**3 # Function to compute escape velocity at a given distance from Earth's center def escape_velocity(r): return np.sqrt(2 * G * M / r) # Initial conditions (different cases for initial velocity) initial_conditions = [ (np.array([7000e3, 0, 0]), np.array([0, 7.12e3, 0])), # Elliptical (less than escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 11.2e3, 0])), # Parabolic (exactly escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 15e3, 0])), # Hyperbolic (greater than escape velocity) ] # Time parameters t_max = 6000 # Maximum time (s) dt = 1 # Time step (s) times = np.arange(0, t_max, dt) # Plot setup fig, ax = plt.subplots(2, 2, figsize=(14, 12)) # Initialize plot styles colors = ['blue', 'green', 'red'] labels = ['Elliptical Trajectory', 'Parabolic Trajectory', 'Hyperbolic Trajectory'] # Loop over different initial conditions to simulate trajectories for i, (r0, v0) in enumerate(initial_conditions): # Initialize arrays to store results positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot trajectory in the first subplot (showing different types) ax[0, 0].plot(positions[:, 0] / 1000, positions[:, 1] / 1000, label=labels[i], color=colors[i]) # Add labels and Earth marker ax[0, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[0, 0].set_title('Orbital Trajectories Near Earth') ax[0, 0].set_xlabel('X Position (km)') ax[0, 0].set_ylabel('Y Position (km)') ax[0, 0].grid(True) ax[0, 0].legend() # Plot escape velocity as a function of distance from Earth's center (second subplot) r_vals = np.linspace(R, 5e7, 100) # from Earth's surface to 50,000 km away v_escape = escape_velocity(r_vals) ax[0, 1].plot(r_vals / 1000, v_escape / 1000, color='purple') ax[0, 1].set_title('Escape Velocity vs. Distance from Earth') ax[0, 1].set_xlabel('Distance from Earth Center (km)') ax[0, 1].set_ylabel('Escape Velocity (km/s)') ax[0, 1].grid(True) # Plot the velocity vectors for different positions (third subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot velocity vectors ax[1, 0].quiver(positions[::100, 0] / 1000, positions[::100, 1] / 1000, velocities[::100, 0] / 1000, velocities[::100, 1] / 1000, angles='xy', scale_units='xy', scale=0.1, color=colors[i], label=labels[i]) ax[1, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[1, 0].set_title('Velocity Vectors of Payloads') ax[1, 0].set_xlabel('X Position (km)') ax[1, 0].set_ylabel('Y Position (km)') ax[1, 0].legend() ax[1, 0].grid(True) # Plot position vs time for all three scenarios (fourth subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot position vs time (radial distance) radial_distance = np.linalg.norm(positions, axis=1) / 1000 # in km ax[1, 1].plot(times / 60, radial_distance, label=labels[i], color=colors[i]) ax[1, 1].set_title('Radial Distance vs Time') ax[1, 1].set_xlabel('Time (minutes)') ax[1, 1].set_ylabel('Radial Distance (km)') ax[1, 1].legend() ax[1, 1].grid(True) plt.tight_layout() plt.show()","title":"4. Python Code Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}