{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Investigation of the Range as a Function of the Angle of Projection 1. Theoretical Foundation Projectile motion is governed by the basic equations of motion under constant acceleration due to gravity. To derive the equations, we consider two components of motion: horizontal (x-direction) and vertical (y-direction). 1.1 Equations of Motion In projectile motion, the only force acting on the projectile (ignoring air resistance) is gravity, which accelerates the object downward with a constant acceleration, \\( g \\) . The horizontal and vertical motions are independent of each other. We can describe each with kinematic equations: Horizontal motion (no acceleration) : $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ where: \\( v_0 \\) is the initial velocity, \\( \\theta \\) is the angle of projection, \\( t \\) is time. Vertical motion (constant acceleration due to gravity) : $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ 1.2 Time of Flight To find the time of flight, we need to determine when the projectile hits the ground, i.e., when \\( y(t) = 0 \\) . Using the vertical motion equation: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factoring out \\( t \\) , we get: \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] The solutions are \\( t = 0 \\) (the initial launch) and \\( t = \\frac{2 v_0 \\sin(\\theta)}{g} \\) (the time when the projectile hits the ground). Thus, the time of flight is: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\] 1.3 Horizontal Range The horizontal range \\( R \\) is the distance traveled in the horizontal direction during the time of flight. From the horizontal motion equation: \\[ R = x(t_f) = v_0 \\cos(\\theta) \\cdot t_f \\] Substituting the expression for \\( t_f \\) : \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] 1.4 Family of Solutions This equation shows how the range \\( R \\) depends on the initial velocity \\( v_0 \\) , the gravitational acceleration \\( g \\) , and the launch angle \\( \\theta \\) . The term \\( \\sin(2\\theta) \\) shows that the range is maximized when \\( \\theta = 45^\\circ \\) because \\( \\sin(90^\\circ) = 1 \\) . Thus, for a given \\( v_0 \\) and \\( g \\) , the range depends on the launch angle. The solution also highlights that the range is symmetric: for any angle \\( \\theta \\) , there is a complementary angle \\( 90^\\circ - \\theta \\) that gives the same range. 2. Analysis of the Range 2.1 Dependence on Launch Angle From the derived equation \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) , we can see that the horizontal range is a function of \\( \\sin(2\\theta) \\) . Therefore, the range is: Maximized at \\( \\theta = 45^\\circ \\) , where \\( \\sin(90^\\circ) = 1 \\) . Zero at \\( \\theta = 0^\\circ \\) and \\( \\theta = 90^\\circ \\) , since \\( \\sin(0^\\circ) = 0 \\) and \\( \\sin(180^\\circ) = 0 \\) . Symmetrical around \\( \\theta = 45^\\circ \\) . 2.2 Dependence on Initial Velocity and Gravitational Acceleration From the equation for the range, we observe that the range \\( R \\) is directly proportional to the square of the initial velocity \\( v_0 \\) and inversely proportional to the gravitational acceleration \\( g \\) . Therefore: Initial velocity : As \\( v_0 \\) increases, the range increases quadratically. This implies that doubling the initial velocity quadruples the range. Gravitational acceleration : The range decreases with an increase in gravitational acceleration, so on a planet with stronger gravity, the range of a projectile would be shorter. 3. Practical Applications This model is a simplified version of projectile motion, which assumes no air resistance and level ground. In real-world applications, several factors influence projectile motion: Air resistance : Drag forces reduce the horizontal range and make the trajectory curve differently. The more streamlined the projectile, the less drag it experiences. Uneven terrain : The model assumes level ground, but if the projectile is launched at an incline or on a hill, the calculations become more complex. Wind : Wind can modify both the trajectory and range by altering the horizontal velocity of the projectile. 4. Implementation Below is a Python script to simulate projectile motion and visualize the range as a function of the launch angle for different initial velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Function to calculate the range based on angle and initial velocity def calculate_range(v0, angle): # Convert angle to radians theta = np.radians(angle) # Range formula R = (v0\\*_2 _ np.sin(2\\*theta)) / g return R # Generate data for multiple initial velocities initial_velocities = [20, 30, 40, 50] # Different initial velocities in m/s angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Plotting plt.figure(figsize=(10,6)) for v0 in initial_velocities: ranges = [calculate_range(v0, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"Investigation of the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigation-of-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigation of the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"Projectile motion is governed by the basic equations of motion under constant acceleration due to gravity. To derive the equations, we consider two components of motion: horizontal (x-direction) and vertical (y-direction).","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#11-equations-of-motion","text":"In projectile motion, the only force acting on the projectile (ignoring air resistance) is gravity, which accelerates the object downward with a constant acceleration, \\( g \\) . The horizontal and vertical motions are independent of each other. We can describe each with kinematic equations: Horizontal motion (no acceleration) : $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ where: \\( v_0 \\) is the initial velocity, \\( \\theta \\) is the angle of projection, \\( t \\) is time. Vertical motion (constant acceleration due to gravity) : $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"1.1 Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#12-time-of-flight","text":"To find the time of flight, we need to determine when the projectile hits the ground, i.e., when \\( y(t) = 0 \\) . Using the vertical motion equation: \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 = 0 \\] Factoring out \\( t \\) , we get: \\[ t (v_0 \\sin(\\theta) - \\frac{1}{2} g t) = 0 \\] The solutions are \\( t = 0 \\) (the initial launch) and \\( t = \\frac{2 v_0 \\sin(\\theta)}{g} \\) (the time when the projectile hits the ground). Thus, the time of flight is: \\[ t_f = \\frac{2 v_0 \\sin(\\theta)}{g} \\]","title":"1.2 Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#13-horizontal-range","text":"The horizontal range \\( R \\) is the distance traveled in the horizontal direction during the time of flight. From the horizontal motion equation: \\[ R = x(t_f) = v_0 \\cos(\\theta) \\cdot t_f \\] Substituting the expression for \\( t_f \\) : \\[ R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} \\] Simplifying: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\]","title":"1.3 Horizontal Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#14-family-of-solutions","text":"This equation shows how the range \\( R \\) depends on the initial velocity \\( v_0 \\) , the gravitational acceleration \\( g \\) , and the launch angle \\( \\theta \\) . The term \\( \\sin(2\\theta) \\) shows that the range is maximized when \\( \\theta = 45^\\circ \\) because \\( \\sin(90^\\circ) = 1 \\) . Thus, for a given \\( v_0 \\) and \\( g \\) , the range depends on the launch angle. The solution also highlights that the range is symmetric: for any angle \\( \\theta \\) , there is a complementary angle \\( 90^\\circ - \\theta \\) that gives the same range.","title":"1.4 Family of Solutions"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-dependence-on-launch-angle","text":"From the derived equation \\( R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\) , we can see that the horizontal range is a function of \\( \\sin(2\\theta) \\) . Therefore, the range is: Maximized at \\( \\theta = 45^\\circ \\) , where \\( \\sin(90^\\circ) = 1 \\) . Zero at \\( \\theta = 0^\\circ \\) and \\( \\theta = 90^\\circ \\) , since \\( \\sin(0^\\circ) = 0 \\) and \\( \\sin(180^\\circ) = 0 \\) . Symmetrical around \\( \\theta = 45^\\circ \\) .","title":"2.1 Dependence on Launch Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-dependence-on-initial-velocity-and-gravitational-acceleration","text":"From the equation for the range, we observe that the range \\( R \\) is directly proportional to the square of the initial velocity \\( v_0 \\) and inversely proportional to the gravitational acceleration \\( g \\) . Therefore: Initial velocity : As \\( v_0 \\) increases, the range increases quadratically. This implies that doubling the initial velocity quadruples the range. Gravitational acceleration : The range decreases with an increase in gravitational acceleration, so on a planet with stronger gravity, the range of a projectile would be shorter.","title":"2.2 Dependence on Initial Velocity and Gravitational Acceleration"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model is a simplified version of projectile motion, which assumes no air resistance and level ground. In real-world applications, several factors influence projectile motion: Air resistance : Drag forces reduce the horizontal range and make the trajectory curve differently. The more streamlined the projectile, the less drag it experiences. Uneven terrain : The model assumes level ground, but if the projectile is launched at an incline or on a hill, the calculations become more complex. Wind : Wind can modify both the trajectory and range by altering the horizontal velocity of the projectile.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation","text":"Below is a Python script to simulate projectile motion and visualize the range as a function of the launch angle for different initial velocities. import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # Acceleration due to gravity (m/s^2) # Function to calculate the range based on angle and initial velocity def calculate_range(v0, angle): # Convert angle to radians theta = np.radians(angle) # Range formula R = (v0\\*_2 _ np.sin(2\\*theta)) / g return R # Generate data for multiple initial velocities initial_velocities = [20, 30, 40, 50] # Different initial velocities in m/s angles = np.linspace(0, 90, 100) # Angles from 0 to 90 degrees # Plotting plt.figure(figsize=(10,6)) for v0 in initial_velocities: ranges = [calculate_range(v0, angle) for angle in angles] plt.plot(angles, ranges, label=f'v0 = {v0} m/s') plt.title('Projectile Range vs Launch Angle') plt.xlabel('Launch Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.show()","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"PROBLEM 2 1. Theoretical Foundation The Forced Damped Pendulum Model The motion of a forced damped pendulum can be described by the following second-order ordinary differential equation (ODE): \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) is the angular displacement of the pendulum as a function of time, \\( \\gamma \\) is the damping coefficient (representing the frictional or resistive forces), \\( \\omega_0 \\) is the natural frequency of the pendulum (which depends on the length and acceleration due to gravity), \\( F_0 \\) is the amplitude of the external driving force, \\( \\omega \\) is the driving angular frequency, and \\( t \\) is time. This equation describes the motion of the pendulum under the influence of both damping and an external periodic force. The term \\( 2 \\gamma \\theta'(t) \\) represents the damping force, \\( \\omega_0^2 \\theta(t) \\) represents the restoring force due to gravity, and \\( F_0 \\cos(\\omega t) \\) is the periodic driving force. Small-Angle Approximation For small oscillations, we can assume that the angle \\( \\theta(t) \\) is small enough that \\( \\sin(\\theta(t)) \\approx \\theta(t) \\) , simplifying the equation of motion to: \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] This is a standard forced damped harmonic oscillator equation, which is more analytically tractable. The solution to this equation depends on several factors, including the damping coefficient, driving frequency, and driving amplitude. Approximate Solution for the Forced Damped Pendulum The general solution to the equation consists of two parts: Homogeneous Solution (related to the system's natural dynamics without the external force): $$ \\theta_h(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) $$ Where \\( A \\) and \\( \\phi \\) are constants determined by initial conditions, and the exponential decay factor \\( e^{-\\gamma t} \\) represents the damping of the system over time. Particular Solution (due to the external driving force): For a steady-state solution, we assume the system reaches a constant amplitude oscillation due to the external force. This solution can be written as: $$ \\theta_p(t) = B \\cos(\\omega t - \\delta) $$ Where \\( B \\) is the amplitude of oscillation and \\( \\delta \\) is the phase shift between the external force and the oscillation. Substituting this into the differential equation and solving for \\( B \\) and \\( \\delta \\) gives us the particular solution: $$ B = \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} $$ $$ \\delta = \\tan^{-1}\\left(\\frac{2 \\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right) $$ Thus, the complete solution to the equation is: \\[ \\theta(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) + \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} \\cos(\\omega t - \\delta) \\] Resonance Conditions and Energy Implications Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) of the pendulum. At resonance, the amplitude of oscillation \\( B \\) becomes large because the denominator in the expression for \\( B \\) becomes very small. In practice, resonance results in the system absorbing maximum energy from the external driving force. The energy absorbed by the system at resonance can be significant, and the oscillation amplitude grows, potentially leading to large motions. This behavior is especially important in engineering, where resonance must be avoided in structures like bridges and buildings to prevent catastrophic failure. 2. Analysis of Dynamics Influence of Damping Coefficient, Driving Amplitude, and Frequency Damping Coefficient ( \\( \\gamma \\) ): As \\( \\gamma \\) increases, the system's oscillations decay more rapidly, reducing the amplitude of oscillation. High damping can suppress resonance effects, limiting the system's ability to oscillate at high amplitudes. Driving Amplitude ( \\( F_0 \\) ): Increasing \\( F_0 \\) increases the amplitude of the system\u2019s steady-state oscillations. However, at very high \\( F_0 \\) , the system may exhibit nonlinear behavior, and the simple harmonic approximation may no longer be valid. Driving Frequency ( \\( \\omega \\) ): The driving frequency affects the resonance condition. If \\( \\omega \\) is close to \\( \\omega_0 \\) , resonance occurs, and the amplitude of oscillations becomes large. Away from resonance, the amplitude decreases. Transition from Regular to Chaotic Motion As the driving amplitude or frequency is varied, the system can transition from regular periodic oscillations to chaotic motion. This can be characterized by sensitivity to initial conditions, where small changes in initial displacement or velocity lead to dramatically different behavior over time. The transition to chaos can be studied using bifurcation diagrams and Poincar\u00e9 sections . 3. Practical Applications Energy Harvesting Devices: The forced damped pendulum can be used in energy harvesting systems where periodic forces are used to extract energy. By tuning the system to resonate with the driving frequency, maximum energy transfer can occur. Suspension Bridges: In suspension bridges, oscillations can be driven by wind or traffic. The design must consider the possibility of resonance, which could lead to destructive oscillations. Oscillating Circuits: Driven RLC circuits, analogous to the forced damped pendulum, demonstrate similar behaviors. Engineers design circuits to avoid resonance to prevent excessive power consumption or damage. 4. Implementation In order to explore these behaviors computationally, a numerical simulation is required. A Python script or Jupyter notebook can be used to simulate the motion of the forced damped pendulum using methods like Runge-Kutta integration for solving the differential equation numerically. Numerical Methods The second-order differential equation can be transformed into a system of first-order differential equations: \\[ \\theta'(t) = v(t) \\] \\[ v'(t) = -2 \\gamma v(t) - \\omega_0^2 \\theta(t) + F_0 \\cos(\\omega t) \\] Using a method like the Runge-Kutta 4th order method , we can integrate these equations over time and observe the system's behavior under different conditions. Phase Diagrams and Poincar\u00e9 Sections Phase Diagram: Plot \\( \\theta(t) \\) vs. \\( v(t) \\) (angular velocity), which shows the system\u2019s trajectory in phase space. Poincar\u00e9 Section: A plot of the system's state at periodic intervals (e.g., every time the pendulum passes through the equilibrium position) to visualize the onset of chaotic behavior. Deliverables Markdown Document: A detailed explanation of the theory and solution for the forced damped pendulum. Discussion on resonance, chaotic behavior, and energy transfer. Python Code/Notebook: Python code to simulate the forced damped pendulum dynamics. Graphical representations of motion, including resonance and chaotic behavior. Visualizations: Phase diagrams and Poincar\u00e9 sections for different parameter settings (damping coefficient, driving amplitude, frequency). Discussion: Analysis of the limitations of the model, such as nonlinear damping, and suggestions for potential extensions (e.g., non-periodic forcing, multi-degree-of-freedom systems). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency of the pendulum F_0 = 1.0 # Driving force amplitude omega = 1.8 # Driving frequency t_span = (0, 50) # Time span for simulation (start, end) initial_conditions = [0.1, 0] # Initial conditions: [theta(0), omega(0)] # Define the system of differential equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -2 * gamma * omega - omega_0**2 * theta + F_0 * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solve the differential equation using the Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, initial_conditions, t_eval=np.linspace(t_span[0], t_span[1], 10000)) # Extract the solution time = sol.t theta = sol.y[0] omega = sol.y[1] # Plot the results # Plot Angular Displacement vs Time plt.figure(figsize=(12, 6)) plt.subplot(2, 2, 1) plt.plot(time, theta, label=\"Angular Displacement (theta)\") plt.title(\"Angular Displacement vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Theta [rad]\") plt.grid(True) # Plot Angular Velocity vs Time plt.subplot(2, 2, 2) plt.plot(time, omega, label=\"Angular Velocity (omega)\", color='orange') plt.title(\"Angular Velocity vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Phase Plot (theta vs omega) plt.subplot(2, 2, 3) plt.plot(theta, omega, label=\"Phase Plot\") plt.title(\"Phase Plot (Theta vs Omega)\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Poincar\u00e9 Section (plot at theta = 0) poincare_section = theta[theta[:-1] * theta[1:] < 0] poincare_omega = omega[:-1][theta[:-1] * theta[1:] < 0] plt.subplot(2, 2, 4) plt.plot(poincare_section, poincare_omega, 'o', label=\"Poincar\u00e9 Section\") plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Show the plots plt.tight_layout() plt.show()","title":"PROBLEM 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"PROBLEM 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#the-forced-damped-pendulum-model","text":"The motion of a forced damped pendulum can be described by the following second-order ordinary differential equation (ODE): \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] Where: \\( \\theta(t) \\) is the angular displacement of the pendulum as a function of time, \\( \\gamma \\) is the damping coefficient (representing the frictional or resistive forces), \\( \\omega_0 \\) is the natural frequency of the pendulum (which depends on the length and acceleration due to gravity), \\( F_0 \\) is the amplitude of the external driving force, \\( \\omega \\) is the driving angular frequency, and \\( t \\) is time. This equation describes the motion of the pendulum under the influence of both damping and an external periodic force. The term \\( 2 \\gamma \\theta'(t) \\) represents the damping force, \\( \\omega_0^2 \\theta(t) \\) represents the restoring force due to gravity, and \\( F_0 \\cos(\\omega t) \\) is the periodic driving force.","title":"The Forced Damped Pendulum Model"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small oscillations, we can assume that the angle \\( \\theta(t) \\) is small enough that \\( \\sin(\\theta(t)) \\approx \\theta(t) \\) , simplifying the equation of motion to: \\[ \\theta''(t) + 2 \\gamma \\theta'(t) + \\omega_0^2 \\theta(t) = F_0 \\cos(\\omega t) \\] This is a standard forced damped harmonic oscillator equation, which is more analytically tractable. The solution to this equation depends on several factors, including the damping coefficient, driving frequency, and driving amplitude.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#approximate-solution-for-the-forced-damped-pendulum","text":"The general solution to the equation consists of two parts: Homogeneous Solution (related to the system's natural dynamics without the external force): $$ \\theta_h(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) $$ Where \\( A \\) and \\( \\phi \\) are constants determined by initial conditions, and the exponential decay factor \\( e^{-\\gamma t} \\) represents the damping of the system over time. Particular Solution (due to the external driving force): For a steady-state solution, we assume the system reaches a constant amplitude oscillation due to the external force. This solution can be written as: $$ \\theta_p(t) = B \\cos(\\omega t - \\delta) $$ Where \\( B \\) is the amplitude of oscillation and \\( \\delta \\) is the phase shift between the external force and the oscillation. Substituting this into the differential equation and solving for \\( B \\) and \\( \\delta \\) gives us the particular solution: $$ B = \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} $$ $$ \\delta = \\tan^{-1}\\left(\\frac{2 \\gamma \\omega}{\\omega_0^2 - \\omega^2}\\right) $$ Thus, the complete solution to the equation is: \\[ \\theta(t) = A e^{-\\gamma t} \\cos(\\omega_0 t + \\phi) + \\frac{F_0}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2 \\gamma \\omega)^2}} \\cos(\\omega t - \\delta) \\]","title":"Approximate Solution for the Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-conditions-and-energy-implications","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) of the pendulum. At resonance, the amplitude of oscillation \\( B \\) becomes large because the denominator in the expression for \\( B \\) becomes very small. In practice, resonance results in the system absorbing maximum energy from the external driving force. The energy absorbed by the system at resonance can be significant, and the oscillation amplitude grows, potentially leading to large motions. This behavior is especially important in engineering, where resonance must be avoided in structures like bridges and buildings to prevent catastrophic failure.","title":"Resonance Conditions and Energy Implications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#influence-of-damping-coefficient-driving-amplitude-and-frequency","text":"Damping Coefficient ( \\( \\gamma \\) ): As \\( \\gamma \\) increases, the system's oscillations decay more rapidly, reducing the amplitude of oscillation. High damping can suppress resonance effects, limiting the system's ability to oscillate at high amplitudes. Driving Amplitude ( \\( F_0 \\) ): Increasing \\( F_0 \\) increases the amplitude of the system\u2019s steady-state oscillations. However, at very high \\( F_0 \\) , the system may exhibit nonlinear behavior, and the simple harmonic approximation may no longer be valid. Driving Frequency ( \\( \\omega \\) ): The driving frequency affects the resonance condition. If \\( \\omega \\) is close to \\( \\omega_0 \\) , resonance occurs, and the amplitude of oscillations becomes large. Away from resonance, the amplitude decreases.","title":"Influence of Damping Coefficient, Driving Amplitude, and Frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#transition-from-regular-to-chaotic-motion","text":"As the driving amplitude or frequency is varied, the system can transition from regular periodic oscillations to chaotic motion. This can be characterized by sensitivity to initial conditions, where small changes in initial displacement or velocity lead to dramatically different behavior over time. The transition to chaos can be studied using bifurcation diagrams and Poincar\u00e9 sections .","title":"Transition from Regular to Chaotic Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Energy Harvesting Devices: The forced damped pendulum can be used in energy harvesting systems where periodic forces are used to extract energy. By tuning the system to resonate with the driving frequency, maximum energy transfer can occur. Suspension Bridges: In suspension bridges, oscillations can be driven by wind or traffic. The design must consider the possibility of resonance, which could lead to destructive oscillations. Oscillating Circuits: Driven RLC circuits, analogous to the forced damped pendulum, demonstrate similar behaviors. Engineers design circuits to avoid resonance to prevent excessive power consumption or damage.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation","text":"In order to explore these behaviors computationally, a numerical simulation is required. A Python script or Jupyter notebook can be used to simulate the motion of the forced damped pendulum using methods like Runge-Kutta integration for solving the differential equation numerically.","title":"4. Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-methods","text":"The second-order differential equation can be transformed into a system of first-order differential equations: \\[ \\theta'(t) = v(t) \\] \\[ v'(t) = -2 \\gamma v(t) - \\omega_0^2 \\theta(t) + F_0 \\cos(\\omega t) \\] Using a method like the Runge-Kutta 4th order method , we can integrate these equations over time and observe the system's behavior under different conditions.","title":"Numerical Methods"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-diagrams-and-poincare-sections","text":"Phase Diagram: Plot \\( \\theta(t) \\) vs. \\( v(t) \\) (angular velocity), which shows the system\u2019s trajectory in phase space. Poincar\u00e9 Section: A plot of the system's state at periodic intervals (e.g., every time the pendulum passes through the equilibrium position) to visualize the onset of chaotic behavior.","title":"Phase Diagrams and Poincar\u00e9 Sections"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#deliverables","text":"Markdown Document: A detailed explanation of the theory and solution for the forced damped pendulum. Discussion on resonance, chaotic behavior, and energy transfer. Python Code/Notebook: Python code to simulate the forced damped pendulum dynamics. Graphical representations of motion, including resonance and chaotic behavior. Visualizations: Phase diagrams and Poincar\u00e9 sections for different parameter settings (damping coefficient, driving amplitude, frequency). Discussion: Analysis of the limitations of the model, such as nonlinear damping, and suggestions for potential extensions (e.g., non-periodic forcing, multi-degree-of-freedom systems). import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants gamma = 0.1 # Damping coefficient omega_0 = 2.0 # Natural frequency of the pendulum F_0 = 1.0 # Driving force amplitude omega = 1.8 # Driving frequency t_span = (0, 50) # Time span for simulation (start, end) initial_conditions = [0.1, 0] # Initial conditions: [theta(0), omega(0)] # Define the system of differential equations def forced_damped_pendulum(t, y): theta, omega = y dtheta_dt = omega domega_dt = -2 * gamma * omega - omega_0**2 * theta + F_0 * np.cos(omega * t) return [dtheta_dt, domega_dt] # Solve the differential equation using the Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, initial_conditions, t_eval=np.linspace(t_span[0], t_span[1], 10000)) # Extract the solution time = sol.t theta = sol.y[0] omega = sol.y[1] # Plot the results # Plot Angular Displacement vs Time plt.figure(figsize=(12, 6)) plt.subplot(2, 2, 1) plt.plot(time, theta, label=\"Angular Displacement (theta)\") plt.title(\"Angular Displacement vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Theta [rad]\") plt.grid(True) # Plot Angular Velocity vs Time plt.subplot(2, 2, 2) plt.plot(time, omega, label=\"Angular Velocity (omega)\", color='orange') plt.title(\"Angular Velocity vs Time\") plt.xlabel(\"Time [s]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Phase Plot (theta vs omega) plt.subplot(2, 2, 3) plt.plot(theta, omega, label=\"Phase Plot\") plt.title(\"Phase Plot (Theta vs Omega)\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Poincar\u00e9 Section (plot at theta = 0) poincare_section = theta[theta[:-1] * theta[1:] < 0] poincare_omega = omega[:-1][theta[:-1] * theta[1:] < 0] plt.subplot(2, 2, 4) plt.plot(poincare_section, poincare_omega, 'o', label=\"Poincar\u00e9 Section\") plt.title(\"Poincar\u00e9 Section\") plt.xlabel(\"Theta [rad]\") plt.ylabel(\"Omega [rad/s]\") plt.grid(True) # Show the plots plt.tight_layout() plt.show()","title":"Deliverables"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius: A Manual Motivation Kepler's Third Law states that the square of a planet's orbital period (T) is proportional to the cube of its orbital radius (R): \\[ T^2 \\propto R^3 \\] This law helps determine planetary motions, celestial masses, and gravitational interactions across different astronomical systems. Derivation of Kepler's Third Law For a circular orbit, the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v^2}{R} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{R} \\] Expressing velocity in terms of the orbital period: \\[ v = \\frac{2 \\pi R}{T} \\Rightarrow \\frac{4 \\pi^2 R^2}{T^2} = \\frac{G M}{R} \\] Rearranging: \\[ T^2 = \\frac{4 \\pi^2 R^3}{G M} \\] This confirms that \\( T^2 \\) is proportional to \\( R^3 \\) . Implications in Astronomy Mass Calculation : Used to determine the mass of stars and planets. Satellite Orbits : Governs artificial and natural satellite motion. Binary Systems : Helps estimate masses of orbiting stars. Real-World Examples Earth\u2019s Orbit Around the Sun \\( R = 1.496 \\times 10^{11} \\) m, \\( T \\approx 365.25 \\) days Verifies the Sun\u2019s mass using Kepler\u2019s Law. Moon\u2019s Orbit Around Earth \\( R = 3.844 \\times 10^8 \\) m, \\( T = 27.3 \\) days Determines Earth\u2019s mass from lunar motion. Graphical Representation Plot of \\( T^2 \\) vs. \\( R^3 \\) : Confirms linear proportionality. Orbit Simulation : Visualizes circular orbital motion. Extension to Elliptical Orbits For elliptical orbits, the semi-major axis \\( a \\) replaces \\( R \\) : \\[ T^2 \\propto a^3 \\] This applies to comets, exoplanets, and non-circular orbits. Conclusion Kepler\u2019s Third Law is fundamental in celestial mechanics, enabling: Prediction of planetary positions, Calculation of celestial masses, Design of satellite trajectories. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # Astronomical Unit in meters def orbital_period(R, M): \"\"\"Calculate the orbital period using Kepler's Third Law.\"\"\" return np.sqrt((4 * np.pi**2 * R**3) / (G * M)) # Define a range of orbital radii (multiples of AU) orbital_radii = np.linspace(0.1, 5, 50) * AU orbital_periods = orbital_period(orbital_radii, M_sun) # Compute square of periods and cube of radii T_squared = orbital_periods**2 R_cubed = orbital_radii**3 # Plot T^2 vs. R^3 to validate Kepler's Third Law plt.figure(figsize=(8, 6)) plt.plot(R_cubed, T_squared, 'bo-', label='Simulated Data') plt.xlabel(\"Orbital Radius Cubed (R\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared (T\u00b2) [s\u00b2]\") plt.title(\"Kepler's Third Law: T\u00b2 vs R\u00b3\") plt.legend() plt.grid() plt.show() # Additional plot: Log-Log scale to show proportionality plt.figure(figsize=(8, 6)) plt.loglog(R_cubed, T_squared, 'ro-', label='Log-Log Relationship') plt.xlabel(\"log(R\u00b3)\") plt.ylabel(\"log(T\u00b2)\") plt.title(\"Kepler's Third Law in Log Scale\") plt.legend() plt.grid(True, which=\"both\", linestyle=\"--\") plt.show() def plot_orbits(radii, labels): \"\"\"Simulate and plot multiple circular orbits in one figure.\"\"\" plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2*np.pi, 100) for radius, label in zip(radii, labels): x = radius * np.cos(theta) y = radius * np.sin(theta) plt.plot(x, y, label=label) plt.plot(0, 0, 'yo', markersize=10, label='Central Body') plt.xlabel(\"X Position [m]\") plt.ylabel(\"Y Position [m]\") plt.title(\"Comparison of Circular Orbits\") plt.legend() plt.grid() plt.axis('equal') plt.show() # Simulate orbits at different radii radii = [0.5 * AU, AU, 2 * AU] labels = [\"0.5 AU Orbit\", \"Earth's Orbit (1 AU)\", \"2 AU Orbit\"] plot_orbits(radii, labels) # Analytical verification: Computing ratio of T^2/R^3 for different radii ratios = T_squared / R_cubed print(f\"Mean value of T^2 / R^3: {np.mean(ratios):.2e} s\u00b2/m\u00b3\") print(\"This confirms the constant proportionality in Kepler's Third Law.\")","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius-a-manual","text":"","title":"Orbital Period and Orbital Radius: A Manual"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of a planet's orbital period (T) is proportional to the cube of its orbital radius (R): \\[ T^2 \\propto R^3 \\] This law helps determine planetary motions, celestial masses, and gravitational interactions across different astronomical systems.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a circular orbit, the gravitational force provides the necessary centripetal force: \\[ \\frac{G M m}{R^2} = \\frac{m v^2}{R} \\] Canceling \\( m \\) and solving for \\( v \\) : \\[ v^2 = \\frac{G M}{R} \\] Expressing velocity in terms of the orbital period: \\[ v = \\frac{2 \\pi R}{T} \\Rightarrow \\frac{4 \\pi^2 R^2}{T^2} = \\frac{G M}{R} \\] Rearranging: \\[ T^2 = \\frac{4 \\pi^2 R^3}{G M} \\] This confirms that \\( T^2 \\) is proportional to \\( R^3 \\) .","title":"Derivation of Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Mass Calculation : Used to determine the mass of stars and planets. Satellite Orbits : Governs artificial and natural satellite motion. Binary Systems : Helps estimate masses of orbiting stars.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#earths-orbit-around-the-sun","text":"\\( R = 1.496 \\times 10^{11} \\) m, \\( T \\approx 365.25 \\) days Verifies the Sun\u2019s mass using Kepler\u2019s Law.","title":"Earth\u2019s Orbit Around the Sun"},{"location":"1%20Physics/2%20Gravity/Problem_1/#moons-orbit-around-earth","text":"\\( R = 3.844 \\times 10^8 \\) m, \\( T = 27.3 \\) days Determines Earth\u2019s mass from lunar motion.","title":"Moon\u2019s Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graphical-representation","text":"Plot of \\( T^2 \\) vs. \\( R^3 \\) : Confirms linear proportionality. Orbit Simulation : Visualizes circular orbital motion.","title":"Graphical Representation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#extension-to-elliptical-orbits","text":"For elliptical orbits, the semi-major axis \\( a \\) replaces \\( R \\) : \\[ T^2 \\propto a^3 \\] This applies to comets, exoplanets, and non-circular orbits.","title":"Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law is fundamental in celestial mechanics, enabling: Prediction of planetary positions, Calculation of celestial masses, Design of satellite trajectories. import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # Astronomical Unit in meters def orbital_period(R, M): \"\"\"Calculate the orbital period using Kepler's Third Law.\"\"\" return np.sqrt((4 * np.pi**2 * R**3) / (G * M)) # Define a range of orbital radii (multiples of AU) orbital_radii = np.linspace(0.1, 5, 50) * AU orbital_periods = orbital_period(orbital_radii, M_sun) # Compute square of periods and cube of radii T_squared = orbital_periods**2 R_cubed = orbital_radii**3 # Plot T^2 vs. R^3 to validate Kepler's Third Law plt.figure(figsize=(8, 6)) plt.plot(R_cubed, T_squared, 'bo-', label='Simulated Data') plt.xlabel(\"Orbital Radius Cubed (R\u00b3) [m\u00b3]\") plt.ylabel(\"Orbital Period Squared (T\u00b2) [s\u00b2]\") plt.title(\"Kepler's Third Law: T\u00b2 vs R\u00b3\") plt.legend() plt.grid() plt.show() # Additional plot: Log-Log scale to show proportionality plt.figure(figsize=(8, 6)) plt.loglog(R_cubed, T_squared, 'ro-', label='Log-Log Relationship') plt.xlabel(\"log(R\u00b3)\") plt.ylabel(\"log(T\u00b2)\") plt.title(\"Kepler's Third Law in Log Scale\") plt.legend() plt.grid(True, which=\"both\", linestyle=\"--\") plt.show() def plot_orbits(radii, labels): \"\"\"Simulate and plot multiple circular orbits in one figure.\"\"\" plt.figure(figsize=(8, 8)) theta = np.linspace(0, 2*np.pi, 100) for radius, label in zip(radii, labels): x = radius * np.cos(theta) y = radius * np.sin(theta) plt.plot(x, y, label=label) plt.plot(0, 0, 'yo', markersize=10, label='Central Body') plt.xlabel(\"X Position [m]\") plt.ylabel(\"Y Position [m]\") plt.title(\"Comparison of Circular Orbits\") plt.legend() plt.grid() plt.axis('equal') plt.show() # Simulate orbits at different radii radii = [0.5 * AU, AU, 2 * AU] labels = [\"0.5 AU Orbit\", \"Earth's Orbit (1 AU)\", \"2 AU Orbit\"] plot_orbits(radii, labels) # Analytical verification: Computing ratio of T^2/R^3 for different radii ratios = T_squared / R_cubed print(f\"Mean value of T^2 / R^3: {np.mean(ratios):.2e} s\u00b2/m\u00b3\") print(\"This confirms the constant proportionality in Kepler's Third Law.\")","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Cosmic Velocities and Escape Velocities Introduction The concept of escape velocity is fundamental in understanding how an object can overcome the gravitational pull of a celestial body, such as Earth or Mars. Beyond escape velocity, there are different thresholds of velocity required to achieve different types of orbits or escape trajectories within a star system. These thresholds are called cosmic velocities . Cosmic Velocities The first, second, and third cosmic velocities define the following: 1. First Cosmic Velocity (Orbital Velocity) This is the velocity required for an object to enter a stable orbit around a celestial body, such as Earth. It is also known as the orbital velocity . An object traveling at this speed will move in a circular orbit at a constant distance from the body\u2019s center. 2. Second Cosmic Velocity (Escape Velocity) This is the velocity required to escape the gravitational influence of the celestial body entirely. This velocity allows an object to break free from the gravitational pull of the body and not return. It is also known as the escape velocity . 3. Third Cosmic Velocity (Escape from the Solar System) This is the velocity required for an object to escape the gravitational influence of the Sun (or any other star) and travel into interstellar space. It is the velocity needed to leave the gravitational influence of a star system entirely. Derivations and Mathematical Foundations The velocities described above are derived using the concept of gravitational potential energy and kinetic energy. The basic formula for gravitational potential energy is: \\[ U = - \\frac{GMm}{r} \\] Where: \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) ), \\( M \\) is the mass of the celestial body, \\( m \\) is the mass of the object, \\( r \\) is the distance from the center of the celestial body. The kinetic energy of an object in motion is given by: \\[ K = \\frac{1}{2} mv^2 \\] Where \\( v \\) is the velocity of the object. 1. First Cosmic Velocity (Orbital Velocity) To find the first cosmic velocity, we balance the centripetal force (required for circular motion) with the gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying, the orbital velocity \\( v_1 \\) is: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] 2. Second Cosmic Velocity (Escape Velocity) For escape velocity, the total mechanical energy (kinetic + potential) must be zero for the object to escape the gravitational pull. The escape velocity \\( v_2 \\) is derived by setting the total energy equal to zero: \\[ \\frac{1}{2} mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\( v_2 \\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\] 3. Third Cosmic Velocity (Velocity to Escape the Sun's Gravitational Influence) The third cosmic velocity is the speed required to escape the Sun's gravity. Assuming the object is at the Earth-Sun distance (1 AU), the formula is: \\[ v_3 = \\sqrt{2GM_{\\text{sun}} \\left( \\frac{1}{r_{\\text{sun}}} - \\frac{1}{r_{\\text{Earth}}} \\right)} \\] Where: \\( M\\_{\\text{sun}} \\) is the mass of the Sun, \\( r\\_{\\text{sun}} \\) is the Sun\u2019s radius, \\( r\\_{\\text{Earth}} \\) is the Earth\u2019s distance from the Sun. Parameters Affecting These Velocities The velocities depend primarily on: The mass ( \\( M \\) ) of the celestial body (for first and second cosmic velocities), The radius ( \\( r \\) ) of the celestial body or the distance from the body (for all cosmic velocities), The gravitational constant \\( G \\) , which remains the same universally, The mass of the Sun for third cosmic velocity, and the Earth's distance from the Sun for its calculation. The greater the mass of the celestial body and the smaller the radius, the higher the velocities required. Cosmic Velocities for Different Celestial Bodies Let's now calculate the first, second, and third cosmic velocities for Earth, Mars, and Jupiter. Parameters for Calculation Earth: \\( M\\_{\\text{Earth}} = 5.972 \\times 10^{24} \\, \\text{kg} \\) \\( r\\_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m} \\) \\( r\\_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\, \\text{m} \\) (distance from Sun) Mars: \\( M\\_{\\text{Mars}} = 6.417 \\times 10^{23} \\, \\text{kg} \\) \\( r\\_{\\text{Mars}} = 3.396 \\times 10^6 \\, \\text{m} \\) Jupiter: \\( M\\_{\\text{Jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg} \\) \\( r\\_{\\text{Jupiter}} = 6.991 \\times 10^7 \\, \\text{m} \\) Now we will calculate the first and second cosmic velocities for these celestial bodies. The third cosmic velocity requires the mass of the Sun and the distances from the Sun, which we can compute for each planet's position. Python Code for Calculation and Visualization import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # mass of the Sun in kg # Function to calculate escape velocity (second cosmic velocity) def escape_velocity(M, r): \"\"\" Calculate escape velocity (second cosmic velocity) \"\"\" return np.sqrt(2 * G * M / r) # Function to calculate orbital velocity (first cosmic velocity) def orbital_velocity(M, r): \"\"\" Calculate orbital velocity (first cosmic velocity) \"\"\" return np.sqrt(G * M / r) # Function to calculate third cosmic velocity (escape from Sun's gravitational influence) def third_cosmic_velocity(distance_from_sun): \"\"\" Calculate third cosmic velocity (escape velocity from Sun) \"\"\" return np.sqrt(2 * G * M_sun * (1 / distance_from_sun)) # Function to calculate velocities for a set of planets def calculate_planetary_velocities(planets): velocities = {} for planet, data in planets.items(): M, r, distance_from_sun = data[\"M\"], data[\"r\"], data[\"distance_from_sun\"] v1 = orbital_velocity(M, r) # First cosmic velocity v2 = escape_velocity(M, r) # Second cosmic velocity v3 = third_cosmic_velocity(distance_from_sun) # Third cosmic velocity velocities[planet] = {'v1': v1, 'v2': v2, 'v3': v3} return velocities # Function to print velocities def print_velocities(velocities): for planet, velocity in velocities.items(): print(f\"Velocities for {planet}:\") print(f\"First Cosmic Velocity (Orbital): {velocity['v1'] / 1000:.2f} km/s\") print(f\"Second Cosmic Velocity (Escape): {velocity['v2'] / 1000:.2f} km/s\") print(f\"Third Cosmic Velocity: {velocity['v3'] / 1000:.2f} km/s\") print() # Function to plot cosmic velocities def plot_cosmic_velocities(velocities): # Extract velocities for plotting planet_names = list(velocities.keys()) v1_vals = [velocities[planet]['v1'] / 1000 for planet in planet_names] # Convert m/s to km/s v2_vals = [velocities[planet]['v2'] / 1000 for planet in planet_names] # Convert m/s to km/s v3_vals = [velocities[planet]['v3'] / 1000 for planet in planet_names] # Convert m/s to km/s # Plotting: Bar plot to show the first, second, and third cosmic velocities plt.figure(figsize=(12, 6)) width = 0.25 # Width of the bars x = np.arange(len(planet_names)) plt.bar(x - width, v1_vals, width, label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.bar(x, v2_vals, width, label=\"Second Cosmic Velocity (Escape)\", color='green') plt.bar(x + width, v3_vals, width, label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xlabel('Planets') plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities for Different Planets') plt.xticks(x, planet_names) plt.legend() plt.tight_layout() plt.show() # Function to plot detailed line plot for cosmic velocities across distances def plot_cosmic_velocities_across_distances(): distances = np.logspace(6, 12, num=100) # Log space for distances, ranging from 10^6 to 10^12 meters planetary_velocities = {'First Cosmic': [], 'Second Cosmic': [], 'Third Cosmic': []} for r in distances: # Calculate the first cosmic velocity for a given distance (orbital velocity) v1 = orbital_velocity(M_sun, r) # Using the mass of the Sun for simplicity planetary_velocities['First Cosmic'].append(v1 / 1000) # Convert to km/s # Calculate the second cosmic velocity for a given distance (escape velocity) v2 = escape_velocity(M_sun, r) # Using the mass of the Sun for escape velocity planetary_velocities['Second Cosmic'].append(v2 / 1000) # Convert to km/s # Calculate the third cosmic velocity for a given distance from the Sun v3 = third_cosmic_velocity(r) planetary_velocities['Third Cosmic'].append(v3 / 1000) # Convert to km/s # Plotting line graph of cosmic velocities as a function of distance plt.figure(figsize=(12, 6)) plt.plot(distances, planetary_velocities['First Cosmic'], label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.plot(distances, planetary_velocities['Second Cosmic'], label=\"Second Cosmic Velocity (Escape)\", color='green') plt.plot(distances, planetary_velocities['Third Cosmic'], label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xscale('log') plt.yscale('log') plt.xlabel('Distance from the center (m)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities as a Function of Distance') plt.legend() plt.tight_layout() plt.show() # Planetary data: (mass in kg, radius in meters, distance from Sun in meters) planets = { \"Earth\": { \"M\": 5.972e24, \"r\": 6.371e6, \"distance_from_sun\": 1.496e11 }, \"Mars\": { \"M\": 6.417e23, \"r\": 3.396e6, \"distance_from_sun\": 2.279e11 }, \"Jupiter\": { \"M\": 1.898e27, \"r\": 6.991e7, \"distance_from_sun\": 7.783e11 } } # Calculate velocities for each planet velocities = calculate_planetary_velocities(planets) # Output the velocities print_velocities(velocities) # Plot the velocities plot_cosmic_velocities(velocities) # Plot the cosmic velocities across distances plot_cosmic_velocities_across_distances()","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-and-escape-velocities","text":"","title":"Cosmic Velocities and Escape Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is fundamental in understanding how an object can overcome the gravitational pull of a celestial body, such as Earth or Mars. Beyond escape velocity, there are different thresholds of velocity required to achieve different types of orbits or escape trajectories within a star system. These thresholds are called cosmic velocities .","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities","text":"The first, second, and third cosmic velocities define the following:","title":"Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity","text":"This is the velocity required for an object to enter a stable orbit around a celestial body, such as Earth. It is also known as the orbital velocity . An object traveling at this speed will move in a circular orbit at a constant distance from the body\u2019s center.","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity","text":"This is the velocity required to escape the gravitational influence of the celestial body entirely. This velocity allows an object to break free from the gravitational pull of the body and not return. It is also known as the escape velocity .","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-escape-from-the-solar-system","text":"This is the velocity required for an object to escape the gravitational influence of the Sun (or any other star) and travel into interstellar space. It is the velocity needed to leave the gravitational influence of a star system entirely.","title":"3. Third Cosmic Velocity (Escape from the Solar System)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#derivations-and-mathematical-foundations","text":"The velocities described above are derived using the concept of gravitational potential energy and kinetic energy. The basic formula for gravitational potential energy is: \\[ U = - \\frac{GMm}{r} \\] Where: \\( G \\) is the gravitational constant ( \\( 6.67430 \\times 10^{-11} \\, \\text{Nm}^2/\\text{kg}^2 \\) ), \\( M \\) is the mass of the celestial body, \\( m \\) is the mass of the object, \\( r \\) is the distance from the center of the celestial body. The kinetic energy of an object in motion is given by: \\[ K = \\frac{1}{2} mv^2 \\] Where \\( v \\) is the velocity of the object.","title":"Derivations and Mathematical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-first-cosmic-velocity-orbital-velocity_1","text":"To find the first cosmic velocity, we balance the centripetal force (required for circular motion) with the gravitational force: \\[ \\frac{mv^2}{r} = \\frac{GMm}{r^2} \\] Simplifying, the orbital velocity \\( v_1 \\) is: \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\]","title":"1. First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-second-cosmic-velocity-escape-velocity_1","text":"For escape velocity, the total mechanical energy (kinetic + potential) must be zero for the object to escape the gravitational pull. The escape velocity \\( v_2 \\) is derived by setting the total energy equal to zero: \\[ \\frac{1}{2} mv^2 - \\frac{GMm}{r} = 0 \\] Solving for \\( v_2 \\) : \\[ v_2 = \\sqrt{\\frac{2GM}{r}} \\]","title":"2. Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-third-cosmic-velocity-velocity-to-escape-the-suns-gravitational-influence","text":"The third cosmic velocity is the speed required to escape the Sun's gravity. Assuming the object is at the Earth-Sun distance (1 AU), the formula is: \\[ v_3 = \\sqrt{2GM_{\\text{sun}} \\left( \\frac{1}{r_{\\text{sun}}} - \\frac{1}{r_{\\text{Earth}}} \\right)} \\] Where: \\( M\\_{\\text{sun}} \\) is the mass of the Sun, \\( r\\_{\\text{sun}} \\) is the Sun\u2019s radius, \\( r\\_{\\text{Earth}} \\) is the Earth\u2019s distance from the Sun.","title":"3. Third Cosmic Velocity (Velocity to Escape the Sun's Gravitational Influence)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-affecting-these-velocities","text":"The velocities depend primarily on: The mass ( \\( M \\) ) of the celestial body (for first and second cosmic velocities), The radius ( \\( r \\) ) of the celestial body or the distance from the body (for all cosmic velocities), The gravitational constant \\( G \\) , which remains the same universally, The mass of the Sun for third cosmic velocity, and the Earth's distance from the Sun for its calculation. The greater the mass of the celestial body and the smaller the radius, the higher the velocities required.","title":"Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#cosmic-velocities-for-different-celestial-bodies","text":"Let's now calculate the first, second, and third cosmic velocities for Earth, Mars, and Jupiter.","title":"Cosmic Velocities for Different Celestial Bodies"},{"location":"1%20Physics/2%20Gravity/Problem_2/#parameters-for-calculation","text":"","title":"Parameters for Calculation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#earth","text":"\\( M\\_{\\text{Earth}} = 5.972 \\times 10^{24} \\, \\text{kg} \\) \\( r\\_{\\text{Earth}} = 6.371 \\times 10^6 \\, \\text{m} \\) \\( r\\_{\\text{Earth-Sun}} = 1.496 \\times 10^{11} \\, \\text{m} \\) (distance from Sun)","title":"Earth:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#mars","text":"\\( M\\_{\\text{Mars}} = 6.417 \\times 10^{23} \\, \\text{kg} \\) \\( r\\_{\\text{Mars}} = 3.396 \\times 10^6 \\, \\text{m} \\)","title":"Mars:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#jupiter","text":"\\( M\\_{\\text{Jupiter}} = 1.898 \\times 10^{27} \\, \\text{kg} \\) \\( r\\_{\\text{Jupiter}} = 6.991 \\times 10^7 \\, \\text{m} \\) Now we will calculate the first and second cosmic velocities for these celestial bodies. The third cosmic velocity requires the mass of the Sun and the distances from the Sun, which we can compute for each planet's position.","title":"Jupiter:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-code-for-calculation-and-visualization","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # gravitational constant (m^3 kg^-1 s^-2) M_sun = 1.989e30 # mass of the Sun in kg # Function to calculate escape velocity (second cosmic velocity) def escape_velocity(M, r): \"\"\" Calculate escape velocity (second cosmic velocity) \"\"\" return np.sqrt(2 * G * M / r) # Function to calculate orbital velocity (first cosmic velocity) def orbital_velocity(M, r): \"\"\" Calculate orbital velocity (first cosmic velocity) \"\"\" return np.sqrt(G * M / r) # Function to calculate third cosmic velocity (escape from Sun's gravitational influence) def third_cosmic_velocity(distance_from_sun): \"\"\" Calculate third cosmic velocity (escape velocity from Sun) \"\"\" return np.sqrt(2 * G * M_sun * (1 / distance_from_sun)) # Function to calculate velocities for a set of planets def calculate_planetary_velocities(planets): velocities = {} for planet, data in planets.items(): M, r, distance_from_sun = data[\"M\"], data[\"r\"], data[\"distance_from_sun\"] v1 = orbital_velocity(M, r) # First cosmic velocity v2 = escape_velocity(M, r) # Second cosmic velocity v3 = third_cosmic_velocity(distance_from_sun) # Third cosmic velocity velocities[planet] = {'v1': v1, 'v2': v2, 'v3': v3} return velocities # Function to print velocities def print_velocities(velocities): for planet, velocity in velocities.items(): print(f\"Velocities for {planet}:\") print(f\"First Cosmic Velocity (Orbital): {velocity['v1'] / 1000:.2f} km/s\") print(f\"Second Cosmic Velocity (Escape): {velocity['v2'] / 1000:.2f} km/s\") print(f\"Third Cosmic Velocity: {velocity['v3'] / 1000:.2f} km/s\") print() # Function to plot cosmic velocities def plot_cosmic_velocities(velocities): # Extract velocities for plotting planet_names = list(velocities.keys()) v1_vals = [velocities[planet]['v1'] / 1000 for planet in planet_names] # Convert m/s to km/s v2_vals = [velocities[planet]['v2'] / 1000 for planet in planet_names] # Convert m/s to km/s v3_vals = [velocities[planet]['v3'] / 1000 for planet in planet_names] # Convert m/s to km/s # Plotting: Bar plot to show the first, second, and third cosmic velocities plt.figure(figsize=(12, 6)) width = 0.25 # Width of the bars x = np.arange(len(planet_names)) plt.bar(x - width, v1_vals, width, label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.bar(x, v2_vals, width, label=\"Second Cosmic Velocity (Escape)\", color='green') plt.bar(x + width, v3_vals, width, label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xlabel('Planets') plt.ylabel('Velocity (km/s)') plt.title('First, Second, and Third Cosmic Velocities for Different Planets') plt.xticks(x, planet_names) plt.legend() plt.tight_layout() plt.show() # Function to plot detailed line plot for cosmic velocities across distances def plot_cosmic_velocities_across_distances(): distances = np.logspace(6, 12, num=100) # Log space for distances, ranging from 10^6 to 10^12 meters planetary_velocities = {'First Cosmic': [], 'Second Cosmic': [], 'Third Cosmic': []} for r in distances: # Calculate the first cosmic velocity for a given distance (orbital velocity) v1 = orbital_velocity(M_sun, r) # Using the mass of the Sun for simplicity planetary_velocities['First Cosmic'].append(v1 / 1000) # Convert to km/s # Calculate the second cosmic velocity for a given distance (escape velocity) v2 = escape_velocity(M_sun, r) # Using the mass of the Sun for escape velocity planetary_velocities['Second Cosmic'].append(v2 / 1000) # Convert to km/s # Calculate the third cosmic velocity for a given distance from the Sun v3 = third_cosmic_velocity(r) planetary_velocities['Third Cosmic'].append(v3 / 1000) # Convert to km/s # Plotting line graph of cosmic velocities as a function of distance plt.figure(figsize=(12, 6)) plt.plot(distances, planetary_velocities['First Cosmic'], label=\"First Cosmic Velocity (Orbital)\", color='blue') plt.plot(distances, planetary_velocities['Second Cosmic'], label=\"Second Cosmic Velocity (Escape)\", color='green') plt.plot(distances, planetary_velocities['Third Cosmic'], label=\"Third Cosmic Velocity (Escape from Sun)\", color='red') # Customize plot plt.xscale('log') plt.yscale('log') plt.xlabel('Distance from the center (m)') plt.ylabel('Velocity (km/s)') plt.title('Cosmic Velocities as a Function of Distance') plt.legend() plt.tight_layout() plt.show() # Planetary data: (mass in kg, radius in meters, distance from Sun in meters) planets = { \"Earth\": { \"M\": 5.972e24, \"r\": 6.371e6, \"distance_from_sun\": 1.496e11 }, \"Mars\": { \"M\": 6.417e23, \"r\": 3.396e6, \"distance_from_sun\": 2.279e11 }, \"Jupiter\": { \"M\": 1.898e27, \"r\": 6.991e7, \"distance_from_sun\": 7.783e11 } } # Calculate velocities for each planet velocities = calculate_planetary_velocities(planets) # Output the velocities print_velocities(velocities) # Plot the velocities plot_cosmic_velocities(velocities) # Plot the cosmic velocities across distances plot_cosmic_velocities_across_distances()","title":"Python Code for Calculation and Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 1. Introduction to Trajectories Near Earth When a payload is released near Earth from a moving rocket, its trajectory depends on several factors: Initial Position : The starting point of the payload relative to Earth. Initial Velocity : The speed and direction of the payload when released. Gravitational Forces : The Earth\u2019s gravitational field acting on the payload. Orbital Mechanics Principles : Newton\u2019s Law of Gravitation, Kepler\u2019s Laws, and the concepts of escape velocity and orbital insertion. 2. Orbital Mechanics Fundamentals Gravitational Force According to Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: \\( F \\) is the gravitational force. \\( G \\) is the gravitational constant. \\( M \\) is the mass of Earth. \\( m \\) is the mass of the payload. \\( r \\) is the distance between the center of the Earth and the payload. Equations of Motion The motion of the payload is governed by Newton's second law, where the gravitational force provides the acceleration: \\[ F = ma = \\frac{GMm}{r^2} \\hat{r} \\] This leads to the second-order differential equations that describe the position and velocity of the payload over time. These equations are usually solved numerically because they involve non-linear terms due to the \\( r^2 \\) dependence in the gravitational force. Escape Velocity The escape velocity is the minimum speed needed for an object to escape Earth's gravitational field, and it can be computed using: \\[ v_e = \\sqrt{\\frac{2GM}{r}} \\] Where: \\( v_e \\) is the escape velocity. \\( r \\) is the distance from the center of Earth. Orbital Types Based on the velocity of the object relative to Earth's gravity, the trajectory can be: Elliptical : If the object's velocity is less than the escape velocity. Parabolic : If the velocity is exactly equal to the escape velocity. Hyperbolic : If the object's velocity is greater than the escape velocity. 3. Numerical Simulation Approach We\u2019ll use Python to implement the simulation. The goal is to numerically solve the equations of motion for a payload under Earth\u2019s gravitational field. 3.1 Initial Setup We'll assume the following initial conditions for simplicity: Initial position \\( r_0 = (x_0, y_0, z_0) \\) . Initial velocity \\( v_0 = (v_x, v_y, v_z) \\) . Earth's gravitational constant \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) . Earth's mass \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) . Earth's radius \\( R = 6371 \\, \\text{km} \\) . 3.2 Solving the Equations of Motion We\u2019ll solve the following system of equations numerically: \\[ r''(t) = -\\frac{GM}{|r(t)|^3} r(t) \\] This requires discretizing time and numerically solving for the position and velocity at each timestep using a numerical integrator like Runge-Kutta or Euler's method. 3.3 Visualization We will visualize the trajectory using matplotlib in Python, creating plots that show the path of the payload, its velocity vector, and the Earth\u2019s gravitational influence. 4. Python Code Implementation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371e3 # Radius of Earth (m) # Function to compute the gravitational force and acceleration def gravitational_acceleration(r): r_magnitude = np.linalg.norm(r) return -G * M * r / r_magnitude**3 # Function to compute escape velocity at a given distance from Earth's center def escape_velocity(r): return np.sqrt(2 * G * M / r) # Initial conditions (different cases for initial velocity) initial_conditions = [ (np.array([7000e3, 0, 0]), np.array([0, 7.12e3, 0])), # Elliptical (less than escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 11.2e3, 0])), # Parabolic (exactly escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 15e3, 0])), # Hyperbolic (greater than escape velocity) ] # Time parameters t_max = 6000 # Maximum time (s) dt = 1 # Time step (s) times = np.arange(0, t_max, dt) # Plot setup fig, ax = plt.subplots(2, 2, figsize=(14, 12)) # Initialize plot styles colors = ['blue', 'green', 'red'] labels = ['Elliptical Trajectory', 'Parabolic Trajectory', 'Hyperbolic Trajectory'] # Loop over different initial conditions to simulate trajectories for i, (r0, v0) in enumerate(initial_conditions): # Initialize arrays to store results positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot trajectory in the first subplot (showing different types) ax[0, 0].plot(positions[:, 0] / 1000, positions[:, 1] / 1000, label=labels[i], color=colors[i]) # Add labels and Earth marker ax[0, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[0, 0].set_title('Orbital Trajectories Near Earth') ax[0, 0].set_xlabel('X Position (km)') ax[0, 0].set_ylabel('Y Position (km)') ax[0, 0].grid(True) ax[0, 0].legend() # Plot escape velocity as a function of distance from Earth's center (second subplot) r_vals = np.linspace(R, 5e7, 100) # from Earth's surface to 50,000 km away v_escape = escape_velocity(r_vals) ax[0, 1].plot(r_vals / 1000, v_escape / 1000, color='purple') ax[0, 1].set_title('Escape Velocity vs. Distance from Earth') ax[0, 1].set_xlabel('Distance from Earth Center (km)') ax[0, 1].set_ylabel('Escape Velocity (km/s)') ax[0, 1].grid(True) # Plot the velocity vectors for different positions (third subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot velocity vectors ax[1, 0].quiver(positions[::100, 0] / 1000, positions[::100, 1] / 1000, velocities[::100, 0] / 1000, velocities[::100, 1] / 1000, angles='xy', scale_units='xy', scale=0.1, color=colors[i], label=labels[i]) ax[1, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[1, 0].set_title('Velocity Vectors of Payloads') ax[1, 0].set_xlabel('X Position (km)') ax[1, 0].set_ylabel('Y Position (km)') ax[1, 0].legend() ax[1, 0].grid(True) # Plot position vs time for all three scenarios (fourth subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot position vs time (radial distance) radial_distance = np.linalg.norm(positions, axis=1) / 1000 # in km ax[1, 1].plot(times / 60, radial_distance, label=labels[i], color=colors[i]) ax[1, 1].set_title('Radial Distance vs Time') ax[1, 1].set_xlabel('Time (minutes)') ax[1, 1].set_ylabel('Radial Distance (km)') ax[1, 1].legend() ax[1, 1].grid(True) plt.tight_layout() plt.show()","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#1-introduction-to-trajectories-near-earth","text":"When a payload is released near Earth from a moving rocket, its trajectory depends on several factors: Initial Position : The starting point of the payload relative to Earth. Initial Velocity : The speed and direction of the payload when released. Gravitational Forces : The Earth\u2019s gravitational field acting on the payload. Orbital Mechanics Principles : Newton\u2019s Law of Gravitation, Kepler\u2019s Laws, and the concepts of escape velocity and orbital insertion.","title":"1. Introduction to Trajectories Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#2-orbital-mechanics-fundamentals","text":"","title":"2. Orbital Mechanics Fundamentals"},{"location":"1%20Physics/2%20Gravity/Problem_3/#gravitational-force","text":"According to Newton's Law of Gravitation: \\[ F = \\frac{GMm}{r^2} \\] Where: \\( F \\) is the gravitational force. \\( G \\) is the gravitational constant. \\( M \\) is the mass of Earth. \\( m \\) is the mass of the payload. \\( r \\) is the distance between the center of the Earth and the payload.","title":"Gravitational Force"},{"location":"1%20Physics/2%20Gravity/Problem_3/#equations-of-motion","text":"The motion of the payload is governed by Newton's second law, where the gravitational force provides the acceleration: \\[ F = ma = \\frac{GMm}{r^2} \\hat{r} \\] This leads to the second-order differential equations that describe the position and velocity of the payload over time. These equations are usually solved numerically because they involve non-linear terms due to the \\( r^2 \\) dependence in the gravitational force.","title":"Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#escape-velocity","text":"The escape velocity is the minimum speed needed for an object to escape Earth's gravitational field, and it can be computed using: \\[ v_e = \\sqrt{\\frac{2GM}{r}} \\] Where: \\( v_e \\) is the escape velocity. \\( r \\) is the distance from the center of Earth.","title":"Escape Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-types","text":"Based on the velocity of the object relative to Earth's gravity, the trajectory can be: Elliptical : If the object's velocity is less than the escape velocity. Parabolic : If the velocity is exactly equal to the escape velocity. Hyperbolic : If the object's velocity is greater than the escape velocity.","title":"Orbital Types"},{"location":"1%20Physics/2%20Gravity/Problem_3/#3-numerical-simulation-approach","text":"We\u2019ll use Python to implement the simulation. The goal is to numerically solve the equations of motion for a payload under Earth\u2019s gravitational field.","title":"3. Numerical Simulation Approach"},{"location":"1%20Physics/2%20Gravity/Problem_3/#31-initial-setup","text":"We'll assume the following initial conditions for simplicity: Initial position \\( r_0 = (x_0, y_0, z_0) \\) . Initial velocity \\( v_0 = (v_x, v_y, v_z) \\) . Earth's gravitational constant \\( G = 6.67430 \\times 10^{-11} \\, \\text{m}^3 \\text{kg}^{-1} \\text{s}^{-2} \\) . Earth's mass \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) . Earth's radius \\( R = 6371 \\, \\text{km} \\) .","title":"3.1 Initial Setup"},{"location":"1%20Physics/2%20Gravity/Problem_3/#32-solving-the-equations-of-motion","text":"We\u2019ll solve the following system of equations numerically: \\[ r''(t) = -\\frac{GM}{|r(t)|^3} r(t) \\] This requires discretizing time and numerically solving for the position and velocity at each timestep using a numerical integrator like Runge-Kutta or Euler's method.","title":"3.2 Solving the Equations of Motion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#33-visualization","text":"We will visualize the trajectory using matplotlib in Python, creating plots that show the path of the payload, its velocity vector, and the Earth\u2019s gravitational influence.","title":"3.3 Visualization"},{"location":"1%20Physics/2%20Gravity/Problem_3/#4-python-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) M = 5.972e24 # Mass of Earth (kg) R = 6371e3 # Radius of Earth (m) # Function to compute the gravitational force and acceleration def gravitational_acceleration(r): r_magnitude = np.linalg.norm(r) return -G * M * r / r_magnitude**3 # Function to compute escape velocity at a given distance from Earth's center def escape_velocity(r): return np.sqrt(2 * G * M / r) # Initial conditions (different cases for initial velocity) initial_conditions = [ (np.array([7000e3, 0, 0]), np.array([0, 7.12e3, 0])), # Elliptical (less than escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 11.2e3, 0])), # Parabolic (exactly escape velocity) (np.array([7000e3, 0, 0]), np.array([0, 15e3, 0])), # Hyperbolic (greater than escape velocity) ] # Time parameters t_max = 6000 # Maximum time (s) dt = 1 # Time step (s) times = np.arange(0, t_max, dt) # Plot setup fig, ax = plt.subplots(2, 2, figsize=(14, 12)) # Initialize plot styles colors = ['blue', 'green', 'red'] labels = ['Elliptical Trajectory', 'Parabolic Trajectory', 'Hyperbolic Trajectory'] # Loop over different initial conditions to simulate trajectories for i, (r0, v0) in enumerate(initial_conditions): # Initialize arrays to store results positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot trajectory in the first subplot (showing different types) ax[0, 0].plot(positions[:, 0] / 1000, positions[:, 1] / 1000, label=labels[i], color=colors[i]) # Add labels and Earth marker ax[0, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[0, 0].set_title('Orbital Trajectories Near Earth') ax[0, 0].set_xlabel('X Position (km)') ax[0, 0].set_ylabel('Y Position (km)') ax[0, 0].grid(True) ax[0, 0].legend() # Plot escape velocity as a function of distance from Earth's center (second subplot) r_vals = np.linspace(R, 5e7, 100) # from Earth's surface to 50,000 km away v_escape = escape_velocity(r_vals) ax[0, 1].plot(r_vals / 1000, v_escape / 1000, color='purple') ax[0, 1].set_title('Escape Velocity vs. Distance from Earth') ax[0, 1].set_xlabel('Distance from Earth Center (km)') ax[0, 1].set_ylabel('Escape Velocity (km/s)') ax[0, 1].grid(True) # Plot the velocity vectors for different positions (third subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot velocity vectors ax[1, 0].quiver(positions[::100, 0] / 1000, positions[::100, 1] / 1000, velocities[::100, 0] / 1000, velocities[::100, 1] / 1000, angles='xy', scale_units='xy', scale=0.1, color=colors[i], label=labels[i]) ax[1, 0].scatter(0, 0, color='orange', s=200, label='Earth', zorder=10) ax[1, 0].set_title('Velocity Vectors of Payloads') ax[1, 0].set_xlabel('X Position (km)') ax[1, 0].set_ylabel('Y Position (km)') ax[1, 0].legend() ax[1, 0].grid(True) # Plot position vs time for all three scenarios (fourth subplot) for i, (r0, v0) in enumerate(initial_conditions): positions = np.zeros((len(times), 3)) velocities = np.zeros((len(times), 3)) # Set initial conditions positions[0] = r0 velocities[0] = v0 # Numerical integration (Euler's method) for j in range(1, len(times)): a = gravitational_acceleration(positions[j-1]) # acceleration due to gravity velocities[j] = velocities[j-1] + a * dt # update velocity positions[j] = positions[j-1] + velocities[j] * dt # update position # Plot position vs time (radial distance) radial_distance = np.linalg.norm(positions, axis=1) / 1000 # in km ax[1, 1].plot(times / 60, radial_distance, label=labels[i], color=colors[i]) ax[1, 1].set_title('Radial Distance vs Time') ax[1, 1].set_xlabel('Time (minutes)') ax[1, 1].set_ylabel('Radial Distance (km)') ax[1, 1].legend() ax[1, 1].grid(True) plt.tight_layout() plt.show()","title":"4. Python Code Implementation"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Wave Interference from Multiple Sources 1. Wave Equation for a Single Point Source A single point source at position \\( (x_0, y_0) \\) emits a circular wave described by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(k r - \\omega t + \\phi) \\] where: \\( A \\) is the amplitude of the wave. \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, related to the wavelength \\( \\lambda \\) . \\( \\omega = 2\\pi f \\) is the angular frequency, where \\( f \\) is the frequency. \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the distance from the source to a given point \\( (x, y) \\) . \\( \\phi \\) is the initial phase. This equation represents a water surface disturbance that propagates outward in circular waves, decreasing in amplitude with distance \\( \\left(\\frac{1}{r}\\right) \\) due to energy spreading. 2. Superposition of Waves from Multiple Sources When multiple point sources exist, the total displacement at a point \\( (x, y) \\) is the sum of all individual wave contributions: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(k r_i - \\omega t + \\phi_i) \\] where: \\( N \\) is the number of wave sources. \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the \\( i \\) -th source to the point \\( (x, y) \\) . Each wave contributes to the overall displacement at \\( (x, y) \\) , and depending on their phase relationships, interference occurs. 3. Positioning of Wave Sources on a Regular Polygon To analyze interference patterns, we position wave sources at the vertices of a regular polygon centered at the origin. The coordinates of each vertex are: \\[ x_i = R \\cos\\left( \\frac{2\\pi i}{N} \\right), \\quad y_i = R \\sin\\left( \\frac{2\\pi i}{N} \\right) \\] where: \\( R \\) is the radius (distance from the center to a vertex). \\( i = 0, 1, 2, \\dots, N-1 \\) (index of each vertex). \\( N \\) is the number of vertices (sides of the polygon). For example: Triangle (N = 3) : Three wave sources positioned at \\( 120^\\circ \\) intervals. Square (N = 4) : Four sources positioned at \\( 90^\\circ \\) intervals. Pentagon (N = 5) : Five sources at \\( 72^\\circ \\) intervals, and so on. 4. Understanding Interference Patterns When multiple sources emit waves simultaneously, they interact in specific ways: (a) Constructive Interference (Amplification) Occurs when waves meet in phase, reinforcing each other. This happens at points where: \\[ k r_i - \\omega t + \\phi_i = 2\\pi m, \\quad m \\in \\mathbb{Z} \\] These regions appear as bright or high-amplitude areas in a graphical representation. (b) Destructive Interference (Cancellation) Occurs when waves meet out of phase, canceling each other. This happens when: \\[ k r_i - \\omega t + \\phi_i = (2m + 1)\\pi, \\quad m \\in \\mathbb{Z} \\] These regions appear as dark or low-amplitude areas. (c) Interference Patterns Based on Polygon Type Each polygon has a unique interference pattern due to differences in source placement: Equilateral Triangle (N=3) : The pattern forms a six-fold symmetry with alternating constructive and destructive regions. Interference creates concentric and radial symmetry around the center. Square (N=4) : The waves form a checkerboard-like pattern with alternating constructive/destructive zones. High symmetry along the diagonal and central axes. Pentagon (N=5) : More complex interference with star-like patterns emerging. Interference fringes appear denser near the center. Higher N (e.g., Hexagon, Octagon) : More sources lead to denser, intricate patterns. Constructive regions form spiral-like or web-like structures . 5. Observing Interference Patterns Graphically By evaluating \\( \\eta\\_{\\text{sum}}(x, y, t) \\) over a grid of \\( (x, y) \\) points and plotting it as a contour map, we can visualize the interference pattern. In these plots: Bright areas indicate constructive interference. Dark areas indicate destructive interference. This graphical approach helps in understanding: How waves reinforce or cancel out. The role of phase differences in pattern formation. The impact of increasing the number of sources. Conclusion Interference patterns arise due to the superposition of waves from multiple sources. Different regular polygons produce distinctive and symmetrical patterns. Constructive interference creates bright regions (high amplitude), while destructive interference results in dark regions (low amplitude). By analyzing these patterns, we gain insight into wave physics, coherence, and superposition principles. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D import matplotlib.animation as animation def wave_interference_polygon(sides=3, radius=5, A=1, k=2, w=2*np.pi, resolution=500, time=0): \"\"\" Simulates wave interference from sources placed at the vertices of a regular polygon. Parameters: - sides: Number of sides of the regular polygon - radius: Distance from the center to each vertex - A: Amplitude of the waves - k: Wave number (related to wavelength) - w: Angular frequency - resolution: Grid resolution for visualization - time: Time instance for animation purposes \"\"\" # Define spatial domain x = np.linspace(-radius*2, radius*2, resolution) y = np.linspace(-radius*2, radius*2, resolution) X, Y = np.meshgrid(x, y) # Compute source positions (polygon vertices) angles = np.linspace(0, 2*np.pi, sides, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A * np.cos(k * r - w * time) / np.sqrt(r + 1e-6) # Small value avoids division by zero # 2D Contour Plot plt.figure(figsize=(8, 8)) plt.contourf(X, Y, eta_sum, levels=200, cmap='plasma') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*sources), color='cyan', marker='o', label='Wave Sources') plt.legend() plt.title(f'Interference Pattern for {sides}-sided Regular Polygon') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show() # 3D Surface Plot fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta_sum, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Pattern for {sides}-sided Polygon') ax.set_xlabel('X Position') ax.set_ylabel('Y Position') ax.set_zlabel('Wave Amplitude') plt.show() def animate_wave_interference(sides=3, frames=60): \"\"\"Creates an animated interference pattern.\"\"\" fig, ax = plt.subplots(figsize=(8, 8)) def update(frame): ax.clear() x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) angles = np.linspace(0, 2*np.pi, sides, endpoint=False) sources = [(5 * np.cos(a), 5 * np.sin(a)) for a in angles] eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += np.cos(2 * r - 2*np.pi * frame / frames) / np.sqrt(r + 1e-6) ax.contourf(X, Y, eta_sum, levels=100, cmap='plasma') ax.scatter(*zip(*sources), color='white', marker='o') ax.set_title(f'Wave Interference Animation (Frame {frame})') ani = animation.FuncAnimation(fig, update, frames=frames, interval=100) plt.show() # Example usage: Generate impressive interference patterns wave_interference_polygon(sides=3) wave_interference_polygon(sides=4) wave_interference_polygon(sides=5) # Run animation (uncomment below to see it) # animate_wave_interference(sides=4)","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-interference-from-multiple-sources","text":"","title":"Wave Interference from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-wave-equation-for-a-single-point-source","text":"A single point source at position \\( (x_0, y_0) \\) emits a circular wave described by: \\[ \\eta(x, y, t) = \\frac{A}{r} \\cos(k r - \\omega t + \\phi) \\] where: \\( A \\) is the amplitude of the wave. \\( k = \\frac{2\\pi}{\\lambda} \\) is the wave number, related to the wavelength \\( \\lambda \\) . \\( \\omega = 2\\pi f \\) is the angular frequency, where \\( f \\) is the frequency. \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) is the distance from the source to a given point \\( (x, y) \\) . \\( \\phi \\) is the initial phase. This equation represents a water surface disturbance that propagates outward in circular waves, decreasing in amplitude with distance \\( \\left(\\frac{1}{r}\\right) \\) due to energy spreading.","title":"1. Wave Equation for a Single Point Source"},{"location":"1%20Physics/3%20Waves/Problem_1/#2-superposition-of-waves-from-multiple-sources","text":"When multiple point sources exist, the total displacement at a point \\( (x, y) \\) is the sum of all individual wave contributions: \\[ \\eta_{\\text{sum}}(x, y, t) = \\sum_{i=1}^{N} \\frac{A}{r_i} \\cos(k r_i - \\omega t + \\phi_i) \\] where: \\( N \\) is the number of wave sources. \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) is the distance from the \\( i \\) -th source to the point \\( (x, y) \\) . Each wave contributes to the overall displacement at \\( (x, y) \\) , and depending on their phase relationships, interference occurs.","title":"2. Superposition of Waves from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-positioning-of-wave-sources-on-a-regular-polygon","text":"To analyze interference patterns, we position wave sources at the vertices of a regular polygon centered at the origin. The coordinates of each vertex are: \\[ x_i = R \\cos\\left( \\frac{2\\pi i}{N} \\right), \\quad y_i = R \\sin\\left( \\frac{2\\pi i}{N} \\right) \\] where: \\( R \\) is the radius (distance from the center to a vertex). \\( i = 0, 1, 2, \\dots, N-1 \\) (index of each vertex). \\( N \\) is the number of vertices (sides of the polygon). For example: Triangle (N = 3) : Three wave sources positioned at \\( 120^\\circ \\) intervals. Square (N = 4) : Four sources positioned at \\( 90^\\circ \\) intervals. Pentagon (N = 5) : Five sources at \\( 72^\\circ \\) intervals, and so on.","title":"3. Positioning of Wave Sources on a Regular Polygon"},{"location":"1%20Physics/3%20Waves/Problem_1/#4-understanding-interference-patterns","text":"When multiple sources emit waves simultaneously, they interact in specific ways:","title":"4. Understanding Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#a-constructive-interference-amplification","text":"Occurs when waves meet in phase, reinforcing each other. This happens at points where: \\[ k r_i - \\omega t + \\phi_i = 2\\pi m, \\quad m \\in \\mathbb{Z} \\] These regions appear as bright or high-amplitude areas in a graphical representation.","title":"(a) Constructive Interference (Amplification)"},{"location":"1%20Physics/3%20Waves/Problem_1/#b-destructive-interference-cancellation","text":"Occurs when waves meet out of phase, canceling each other. This happens when: \\[ k r_i - \\omega t + \\phi_i = (2m + 1)\\pi, \\quad m \\in \\mathbb{Z} \\] These regions appear as dark or low-amplitude areas.","title":"(b) Destructive Interference (Cancellation)"},{"location":"1%20Physics/3%20Waves/Problem_1/#c-interference-patterns-based-on-polygon-type","text":"Each polygon has a unique interference pattern due to differences in source placement: Equilateral Triangle (N=3) : The pattern forms a six-fold symmetry with alternating constructive and destructive regions. Interference creates concentric and radial symmetry around the center. Square (N=4) : The waves form a checkerboard-like pattern with alternating constructive/destructive zones. High symmetry along the diagonal and central axes. Pentagon (N=5) : More complex interference with star-like patterns emerging. Interference fringes appear denser near the center. Higher N (e.g., Hexagon, Octagon) : More sources lead to denser, intricate patterns. Constructive regions form spiral-like or web-like structures .","title":"(c) Interference Patterns Based on Polygon Type"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-observing-interference-patterns-graphically","text":"By evaluating \\( \\eta\\_{\\text{sum}}(x, y, t) \\) over a grid of \\( (x, y) \\) points and plotting it as a contour map, we can visualize the interference pattern. In these plots: Bright areas indicate constructive interference. Dark areas indicate destructive interference. This graphical approach helps in understanding: How waves reinforce or cancel out. The role of phase differences in pattern formation. The impact of increasing the number of sources.","title":"5. Observing Interference Patterns Graphically"},{"location":"1%20Physics/3%20Waves/Problem_1/#conclusion","text":"Interference patterns arise due to the superposition of waves from multiple sources. Different regular polygons produce distinctive and symmetrical patterns. Constructive interference creates bright regions (high amplitude), while destructive interference results in dark regions (low amplitude). By analyzing these patterns, we gain insight into wave physics, coherence, and superposition principles. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D import matplotlib.animation as animation def wave_interference_polygon(sides=3, radius=5, A=1, k=2, w=2*np.pi, resolution=500, time=0): \"\"\" Simulates wave interference from sources placed at the vertices of a regular polygon. Parameters: - sides: Number of sides of the regular polygon - radius: Distance from the center to each vertex - A: Amplitude of the waves - k: Wave number (related to wavelength) - w: Angular frequency - resolution: Grid resolution for visualization - time: Time instance for animation purposes \"\"\" # Define spatial domain x = np.linspace(-radius*2, radius*2, resolution) y = np.linspace(-radius*2, radius*2, resolution) X, Y = np.meshgrid(x, y) # Compute source positions (polygon vertices) angles = np.linspace(0, 2*np.pi, sides, endpoint=False) sources = [(radius * np.cos(a), radius * np.sin(a)) for a in angles] # Superpose waves from all sources eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += A * np.cos(k * r - w * time) / np.sqrt(r + 1e-6) # Small value avoids division by zero # 2D Contour Plot plt.figure(figsize=(8, 8)) plt.contourf(X, Y, eta_sum, levels=200, cmap='plasma') plt.colorbar(label='Wave Amplitude') plt.scatter(*zip(*sources), color='cyan', marker='o', label='Wave Sources') plt.legend() plt.title(f'Interference Pattern for {sides}-sided Regular Polygon') plt.xlabel('X Position') plt.ylabel('Y Position') plt.show() # 3D Surface Plot fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot_surface(X, Y, eta_sum, cmap='viridis', edgecolor='none') ax.set_title(f'3D Interference Pattern for {sides}-sided Polygon') ax.set_xlabel('X Position') ax.set_ylabel('Y Position') ax.set_zlabel('Wave Amplitude') plt.show() def animate_wave_interference(sides=3, frames=60): \"\"\"Creates an animated interference pattern.\"\"\" fig, ax = plt.subplots(figsize=(8, 8)) def update(frame): ax.clear() x = np.linspace(-10, 10, 500) y = np.linspace(-10, 10, 500) X, Y = np.meshgrid(x, y) angles = np.linspace(0, 2*np.pi, sides, endpoint=False) sources = [(5 * np.cos(a), 5 * np.sin(a)) for a in angles] eta_sum = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) eta_sum += np.cos(2 * r - 2*np.pi * frame / frames) / np.sqrt(r + 1e-6) ax.contourf(X, Y, eta_sum, levels=100, cmap='plasma') ax.scatter(*zip(*sources), color='white', marker='o') ax.set_title(f'Wave Interference Animation (Frame {frame})') ani = animation.FuncAnimation(fig, update, frames=frames, interval=100) plt.show() # Example usage: Generate impressive interference patterns wave_interference_polygon(sides=3) wave_interference_polygon(sides=4) wave_interference_polygon(sides=5) # Run animation (uncomment below to see it) # animate_wave_interference(sides=4)","title":"Conclusion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force 1. Introduction The Lorentz Force , given by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] describes the motion of a charged particle in the presence of electric and magnetic fields. This force plays a key role in plasma physics, particle accelerators, and astrophysics. In this study, we implement a simulation to visualize and analyze the effects of electric and magnetic fields on charged particles. 2. Applications of the Lorentz Force 1. Particle Accelerators Used in cyclotrons and synchrotrons. Magnetic fields guide and bend particle trajectories. Electric fields accelerate charged particles. 2. Mass Spectrometers Separates ions based on charge-to-mass ratio (q/m). Magnetic fields cause circular motion based on velocity and mass. 3. Plasma Confinement (Tokamaks, Stellarators) Used in fusion reactors to confine hot plasma. Particles spiral along magnetic field lines, reducing energy loss. 3. Particle Motion in Different Field Configurations Case 1: Uniform Magnetic Field The particle moves in a circular trajectory (cyclotron motion). The Larmor radius is given by: $$ r_L = \\frac{m v_{\\perp}}{q B} $$ The cyclotron frequency : $$ \\omega_c = \\frac{q B}{m} $$ Case 2: Combined Uniform Electric and Magnetic Fields Results in helical motion . Circular motion in the perpendicular plane combined with acceleration in the electric field direction. Case 3: Crossed Electric and Magnetic Fields The particle undergoes E \u00d7 B drift with velocity: $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$ 4. Numerical Approach Using Newton\u2019s Second Law : \\[ m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] We solve the equations of motion using the Euler method : \\[ \\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m} \\Delta t \\] \\[ \\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t) \\Delta t \\] 5. Python Implementation import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) dt = 1e-10 # Time step (seconds) total_time = 1e-6 # Total simulation time (seconds) # Field configurations E = np.array([0, 0, 0]) # Electric field (V/m) B = np.array([0, 0, 1]) # Magnetic field (Tesla) # Initial conditions v0 = np.array([1e6, 1e6, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) # Time array time_steps = int(total_time / dt) t = np.linspace(0, total_time, time_steps) # Arrays to store position and velocity positions = np.zeros((time_steps, 3)) velocities = np.zeros((time_steps, 3)) positions[0] = r0 velocities[0] = v0 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) / m def rk4_step(r, v, dt): \"\"\"Computes one step using the 4th-order Runge-Kutta method.\"\"\" k1_v = lorentz_force(v, E, B) * dt k1_r = v * dt k2_v = lorentz_force(v + k1_v / 2, E, B) * dt k2_r = (v + k1_v / 2) * dt k3_v = lorentz_force(v + k2_v / 2, E, B) * dt k3_r = (v + k2_v / 2) * dt k4_v = lorentz_force(v + k3_v, E, B) * dt k4_r = (v + k3_v) * dt v_new = v + (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6 r_new = r + (k1_r + 2*k2_r + 2*k3_r + k4_r) / 6 return r_new, v_new # Solve motion using RK4 for i in range(1, time_steps): positions[i], velocities[i] = rk4_step(positions[i-1], velocities[i-1], dt) # Visualization fig = plt.figure(figsize=(12, 5)) # 2D Projection (XY Plane) ax1 = fig.add_subplot(121) ax1.plot(positions[:, 0], positions[:, 1], color='b', linewidth=1.2) ax1.set_title(\"Particle Trajectory in XY Plane\") ax1.set_xlabel(\"X Position (m)\") ax1.set_ylabel(\"Y Position (m)\") ax1.grid() # 3D Trajectory ax2 = fig.add_subplot(122, projection='3d') ax2.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='r', linewidth=1.2) ax2.set_title(\"3D Particle Trajectory\") ax2.set_xlabel(\"X Position (m)\") ax2.set_ylabel(\"Y Position (m)\") ax2.set_zlabel(\"Z Position (m)\") plt.tight_layout() plt.show()","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-introduction","text":"The Lorentz Force , given by: \\[ \\mathbf{F} = q\\mathbf{E} + q\\mathbf{v} \\times \\mathbf{B} \\] describes the motion of a charged particle in the presence of electric and magnetic fields. This force plays a key role in plasma physics, particle accelerators, and astrophysics. In this study, we implement a simulation to visualize and analyze the effects of electric and magnetic fields on charged particles.","title":"1. Introduction"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-applications-of-the-lorentz-force","text":"","title":"2. Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-particle-accelerators","text":"Used in cyclotrons and synchrotrons. Magnetic fields guide and bend particle trajectories. Electric fields accelerate charged particles.","title":"1. Particle Accelerators"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-mass-spectrometers","text":"Separates ions based on charge-to-mass ratio (q/m). Magnetic fields cause circular motion based on velocity and mass.","title":"2. Mass Spectrometers"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-plasma-confinement-tokamaks-stellarators","text":"Used in fusion reactors to confine hot plasma. Particles spiral along magnetic field lines, reducing energy loss.","title":"3. Plasma Confinement (Tokamaks, Stellarators)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-particle-motion-in-different-field-configurations","text":"","title":"3. Particle Motion in Different Field Configurations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-1-uniform-magnetic-field","text":"The particle moves in a circular trajectory (cyclotron motion). The Larmor radius is given by: $$ r_L = \\frac{m v_{\\perp}}{q B} $$ The cyclotron frequency : $$ \\omega_c = \\frac{q B}{m} $$","title":"Case 1: Uniform Magnetic Field"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-2-combined-uniform-electric-and-magnetic-fields","text":"Results in helical motion . Circular motion in the perpendicular plane combined with acceleration in the electric field direction.","title":"Case 2: Combined Uniform Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#case-3-crossed-electric-and-magnetic-fields","text":"The particle undergoes E \u00d7 B drift with velocity: $$ \\mathbf{v}_d = \\frac{\\mathbf{E} \\times \\mathbf{B}}{B^2} $$","title":"Case 3: Crossed Electric and Magnetic Fields"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-numerical-approach","text":"Using Newton\u2019s Second Law : \\[ m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] We solve the equations of motion using the Euler method : \\[ \\mathbf{v}(t + \\Delta t) = \\mathbf{v}(t) + \\frac{\\mathbf{F}(t)}{m} \\Delta t \\] \\[ \\mathbf{r}(t + \\Delta t) = \\mathbf{r}(t) + \\mathbf{v}(t) \\Delta t \\]","title":"4. Numerical Approach"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#5-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) dt = 1e-10 # Time step (seconds) total_time = 1e-6 # Total simulation time (seconds) # Field configurations E = np.array([0, 0, 0]) # Electric field (V/m) B = np.array([0, 0, 1]) # Magnetic field (Tesla) # Initial conditions v0 = np.array([1e6, 1e6, 0]) # Initial velocity (m/s) r0 = np.array([0, 0, 0]) # Initial position (m) # Time array time_steps = int(total_time / dt) t = np.linspace(0, total_time, time_steps) # Arrays to store position and velocity positions = np.zeros((time_steps, 3)) velocities = np.zeros((time_steps, 3)) positions[0] = r0 velocities[0] = v0 def lorentz_force(v, E, B): return q * (E + np.cross(v, B)) / m def rk4_step(r, v, dt): \"\"\"Computes one step using the 4th-order Runge-Kutta method.\"\"\" k1_v = lorentz_force(v, E, B) * dt k1_r = v * dt k2_v = lorentz_force(v + k1_v / 2, E, B) * dt k2_r = (v + k1_v / 2) * dt k3_v = lorentz_force(v + k2_v / 2, E, B) * dt k3_r = (v + k2_v / 2) * dt k4_v = lorentz_force(v + k3_v, E, B) * dt k4_r = (v + k3_v) * dt v_new = v + (k1_v + 2*k2_v + 2*k3_v + k4_v) / 6 r_new = r + (k1_r + 2*k2_r + 2*k3_r + k4_r) / 6 return r_new, v_new # Solve motion using RK4 for i in range(1, time_steps): positions[i], velocities[i] = rk4_step(positions[i-1], velocities[i-1], dt) # Visualization fig = plt.figure(figsize=(12, 5)) # 2D Projection (XY Plane) ax1 = fig.add_subplot(121) ax1.plot(positions[:, 0], positions[:, 1], color='b', linewidth=1.2) ax1.set_title(\"Particle Trajectory in XY Plane\") ax1.set_xlabel(\"X Position (m)\") ax1.set_ylabel(\"Y Position (m)\") ax1.grid() # 3D Trajectory ax2 = fig.add_subplot(122, projection='3d') ax2.plot(positions[:, 0], positions[:, 1], positions[:, 2], color='r', linewidth=1.2) ax2.set_title(\"3D Particle Trajectory\") ax2.set_xlabel(\"X Position (m)\") ax2.set_ylabel(\"Y Position (m)\") ax2.set_zlabel(\"Z Position (m)\") plt.tight_layout() plt.show()","title":"5. Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Task 1: Simplified Algorithm Description Introduction Calculating the equivalent resistance of a circuit is fundamental in electrical engineering. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a more systematic and algorithmic approach to solving this problem. In this approach: Nodes represent junctions in the circuit. Edges represent resistors, with the resistance values as the weights of the edges. This document describes the algorithm for calculating the equivalent resistance of a circuit using graph theory. Key Concepts for the Algorithm Series Connection: Series connection : Resistors are connected end-to-end, and the total resistance is the sum of individual resistances. Formula for series resistors: $$ R_{eq} = R_1 + R_2 + \\cdots + R_n $$ Example: For two resistors \\( R_1 = 6 \\, \\Omega \\) and \\( R_2 = 3 \\, \\Omega \\) in series: $$ R_{eq} = R_1 + R_2 = 6 + 3 = 9 \\, \\Omega $$ Parallel Connection: Parallel connection : Resistors have both terminals connected to the same pair of nodes, and the total resistance is found using the parallel resistance formula. Formula for parallel resistors: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$ Example: For two resistors \\( R_1 = 6 \\, \\Omega \\) and \\( R_2 = 3 \\, \\Omega \\) in parallel: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} = \\frac{1}{6} + \\frac{1}{3} = \\frac{1}{R_{eq}} = \\frac{1}{2} $$ Thus, the equivalent resistance is: $$ R_{eq} = 2 \\, \\Omega $$ Algorithm Description The algorithm simplifies the circuit by iteratively reducing the graph . This reduction involves identifying series and parallel connections and simplifying them step by step until only one node remains, representing the total equivalent resistance. Step 1: Represent the Circuit as a Graph Nodes : Each junction in the circuit is represented by a node in the graph. Edges : Each resistor is represented as an edge between two nodes, with the resistance as the weight of the edge. Example: Two resistors \\( R_1 = 6 \\, \\Omega \\) and \\( R_2 = 3 \\, \\Omega \\) in series: \\( R_1 \\) is connected to node 1, and \\( R_2 \\) is connected between node 2 and node 3. The graph representation has three nodes (1, 2, and 3) and two edges representing \\( R_1 \\) and \\( R_2 \\) . Step 2: Detect Series and Parallel Connections We will iteratively reduce the graph by simplifying the series and parallel connections. Series Connections: If two resistors are in series (i.e., connected end-to-end), combine them by adding their resistance values. For two resistors \\( R_1 \\) and \\( R_2 \\) in series, the equivalent resistance is: $$ R_{eq} = R_1 + R_2 $$ This process is repeated until no more simple series connections are left. Parallel Connections: If two resistors are in parallel (i.e., connected between the same two nodes), combine them using the parallel formula. For two resistors \\( R_1 \\) and \\( R_2 \\) in parallel, the equivalent resistance is: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ This process is repeated until no more simple parallel connections are left. Step 3: Iterative Graph Reduction After identifying and simplifying the series and parallel connections, the graph is reduced step-by-step: Identify series connections : Traverse the graph and check for resistors that are connected in series. Once identified, combine them by adding their resistance values. Identify parallel connections : Similarly, check for resistors that are connected in parallel. Combine them using the parallel resistance formula. Repeat the process : After each reduction (whether series or parallel), the graph is updated. New series or parallel connections may emerge from the simplification, so the process is repeated until the graph is reduced to a single equivalent resistance. Step 4: Final Simplification The algorithm continues simplifying the circuit until only one node remains, and the resistance of this node is the equivalent resistance of the entire circuit. Pseudocode for the Algorithm Algorithm: Calculate Equivalent Resistance Using Graph Theory Input: Graph G with nodes representing junctions and edges representing resistors Output: Equivalent resistance of the entire circuit 1. Initialize the graph G with nodes and resistors (edges with weights). 2. While the graph contains more than one node: a. Detect and simplify **series connections**: - For each pair of nodes connected by resistors in series: - Combine the resistances by adding their weights. - Remove the original nodes and replace them with a new node that has the combined resistance. b. Detect and simplify **parallel connections**: - For each set of nodes connected by resistors in parallel: - Combine the resistances using the parallel formula. - Remove the original resistors and replace them with a new equivalent resistor. 3. Once the graph is reduced to a single node, return the equivalent resistance of that node. Step-by-Step Solution for Task 2: Equivalent Resistance Calculation Using Graph Theory Key Concepts: Series Resistors: The equivalent resistance of two resistors \\( R_1 \\) and \\( R_2 \\) in series is simply the sum: $$ R_{eq} = R_1 + R_2 $$ Parallel Resistors: The equivalent resistance of two resistors \\( R_1 \\) and \\( R_2 \\) in parallel is given by: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ Graph Representation: Nodes represent junctions in the circuit. Edges represent resistors with weights equal to their resistance values. The circuit is represented as an undirected graph, where the resistors are edges with weights, and the junctions are the nodes. Simplification Process: Series Resistor Simplification: If two resistors are in series, their resistances add up. For nodes \\( A \\) , \\( B \\) , and \\( C \\) , where \\( A \\) is connected to \\( B \\) and \\( B \\) is connected to \\( C \\) , replace the two resistors (edges) with one equivalent resistor whose resistance is the sum of the two. $$ R_{eq} = R_1 + R_2 $$ After the simplification, remove the two original resistors and add a new one between \\( A \\) and \\( C \\) . Parallel Resistor Simplification: If two resistors are in parallel, their combined resistance is given by the formula: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ For nodes \\( A \\) , \\( B \\) , and \\( C \\) , where \\( A \\) is connected to \\( B \\) , and \\( B \\) is connected to \\( C \\) , replace the two resistors (edges) with one equivalent resistor using the formula above. Remove the two original resistors and add a new one between \\( A \\) and \\( C \\) . Step-by-Step Process: 1. Graph Creation: First, a graph is created using the networkx library where: Nodes represent junctions in the circuit. Edges represent the resistors, with each edge having a weight representing the resistance value. Example: Resistor \\( R_1 = 6 \\) ohms between nodes 1 and 2. Resistor \\( R_2 = 3 \\) ohms between nodes 2 and 3. Resistor \\( R_3 = 4 \\) ohms between nodes 3 and 4. Resistor \\( R_4 = 5 \\) ohms between nodes 2 and 5. Resistor \\( R_5 = 2 \\) ohms between nodes 4 and 6. 2. Series Resistor Detection: Identify two resistors that are connected in series by looking for nodes that have exactly two neighbors. Apply the series simplification formula to these pairs and replace them with a single equivalent resistor. Example: If \\( R_1 \\) and \\( R_2 \\) are in series, their equivalent resistance will be: $$ R_{eq} = R_1 + R_2 $$ After simplification, update the graph with a new edge that represents the equivalent resistance. 3. Parallel Resistor Detection: Identify two resistors that are connected in parallel by looking for nodes that have two neighbors with the same connecting node. Apply the parallel simplification formula to these pairs and replace them with a single equivalent resistor. Example: If \\( R_2 \\) and \\( R_3 \\) are in parallel, their equivalent resistance will be: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_2} + \\frac{1}{R_3} $$ After simplification, update the graph with a new edge that represents the equivalent resistance. 4. Repeat Simplification: Continue the simplification process until only one edge remains in the graph. The remaining edge represents the equivalent resistance of the entire circuit. 5. Final Result: The final equivalent resistance is the weight of the last remaining edge in the graph, which is the simplified result of the entire circuit. Example Circuit: Graph Representation: Nodes: \\( 1, 2, 3, 4, 5, 6 \\) Edges: \\( (1, 2, R_1 = 6 \\, \\Omega) \\) \\( (2, 3, R_2 = 3 \\, \\Omega) \\) \\( (3, 4, R_3 = 4 \\, \\Omega) \\) \\( (2, 5, R_4 = 5 \\, \\Omega) \\) \\( (4, 6, R_5 = 2 \\, \\Omega) \\) import networkx as nx import matplotlib.pyplot as plt # Function to plot the graph for visualization def plot_graph(G, title=\"Circuit Graph\"): pos = nx.spring_layout(G) # Layout for better visualization plt.figure(figsize=(10, 8)) node_size = [500 + 100 * G.degree(node) for node in G.nodes] node_color = ['lightgreen' if G.degree(node) == 1 else 'lightblue' for node in G.nodes] nx.draw(G, pos, with_labels=True, node_color=node_color, node_size=node_size, font_size=15, font_weight=\"bold\", edge_color=\"gray\") edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12) plt.title(title) plt.axis('off') # Hide axes for a cleaner presentation plt.show() # Function to find series resistors def find_series_resistors(G): series_pairs = [] for node in G.nodes: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Exactly two neighbors for series connection if G[node][neighbors[0]]['weight'] and G[node][neighbors[1]]['weight']: series_pairs.append((node, neighbors[0], neighbors[1])) return series_pairs # Function to find parallel resistors def find_parallel_resistors(G): parallel_pairs = [] for node in G.nodes: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Exactly two neighbors for parallel connection if G[node][neighbors[0]]['weight'] and G[node][neighbors[1]]['weight']: parallel_pairs.append((node, neighbors[0], neighbors[1])) return parallel_pairs # Function to simplify a series resistor def simplify_series(G, series_pair): node1, node2, node3 = series_pair R1 = G[node2][node1]['weight'] R2 = G[node3][node2]['weight'] R_eq = R1 + R2 # Series combination # Remove the two resistors and add the equivalent one G.remove_edge(node2, node1) G.remove_edge(node3, node2) G.add_edge(node1, node3, weight=R_eq) return G # Function to simplify a parallel resistor def simplify_parallel(G, parallel_pair): node1, node2, node3 = parallel_pair R1 = G[node1][node2]['weight'] R2 = G[node2][node3]['weight'] R_eq = 1 / (1 / R1 + 1 / R2) # Parallel combination # Remove the two resistors and add the equivalent one G.remove_edge(node1, node2) G.remove_edge(node2, node3) G.add_edge(node1, node3, weight=R_eq) return G # Main function to calculate equivalent resistance def calculate_equivalent_resistance(G): # Initial graph plot plot_graph(G, title=\"Initial Circuit Graph\") step = 1 # Keep simplifying the graph until only one edge remains while len(G.edges) > 1: # Simplify series connections series_pairs = find_series_resistors(G) if series_pairs: print(f\"Step {step}: Simplifying series pairs: {series_pairs}\") for series_pair in series_pairs: G = simplify_series(G, series_pair) # Plot after simplifying series resistors plot_graph(G, title=f\"After Step {step}: Simplified Series Resistors\") # Simplify parallel connections parallel_pairs = find_parallel_resistors(G) if parallel_pairs: print(f\"Step {step}: Simplifying parallel pairs: {parallel_pairs}\") for parallel_pair in parallel_pairs: G = simplify_parallel(G, parallel_pair) # Plot after simplifying parallel resistors plot_graph(G, title=f\"After Step {step}: Simplified Parallel Resistors\") step += 1 # The final equivalent resistance is the only edge left in the graph final_resistance = None for edge in G.edges(data=True): final_resistance = edge[2]['weight'] return final_resistance # Example usage: Create a circuit graph G = nx.Graph() # Adding resistors (edges) to the circuit # Resistor values: R1 = 6 ohms, R2 = 3 ohms, R3 = 4 ohms, R4 = 5 ohms, R5 = 2 ohms G.add_edge(1, 2, weight=6) # R1 G.add_edge(2, 3, weight=3) # R2 G.add_edge(3, 4, weight=4) # R3 G.add_edge(2, 5, weight=5) # R4 G.add_edge(4, 6, weight=2) # R5 # Call the function to calculate the equivalent resistance equivalent_resistance = calculate_equivalent_resistance(G) print(f\"The equivalent resistance of the circuit is: {equivalent_resistance} ohms\")","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#task-1-simplified-algorithm-description","text":"","title":"Task 1: Simplified Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#introduction","text":"Calculating the equivalent resistance of a circuit is fundamental in electrical engineering. While traditional methods involve iteratively applying series and parallel resistor rules, these approaches can become cumbersome for complex circuits with many components. Graph theory offers a more systematic and algorithmic approach to solving this problem. In this approach: Nodes represent junctions in the circuit. Edges represent resistors, with the resistance values as the weights of the edges. This document describes the algorithm for calculating the equivalent resistance of a circuit using graph theory.","title":"Introduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts-for-the-algorithm","text":"","title":"Key Concepts for the Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"Series connection : Resistors are connected end-to-end, and the total resistance is the sum of individual resistances. Formula for series resistors: $$ R_{eq} = R_1 + R_2 + \\cdots + R_n $$ Example: For two resistors \\( R_1 = 6 \\, \\Omega \\) and \\( R_2 = 3 \\, \\Omega \\) in series: $$ R_{eq} = R_1 + R_2 = 6 + 3 = 9 \\, \\Omega $$","title":"Series Connection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"Parallel connection : Resistors have both terminals connected to the same pair of nodes, and the total resistance is found using the parallel resistance formula. Formula for parallel resistors: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\cdots + \\frac{1}{R_n} $$ Example: For two resistors \\( R_1 = 6 \\, \\Omega \\) and \\( R_2 = 3 \\, \\Omega \\) in parallel: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} = \\frac{1}{6} + \\frac{1}{3} = \\frac{1}{R_{eq}} = \\frac{1}{2} $$ Thus, the equivalent resistance is: $$ R_{eq} = 2 \\, \\Omega $$","title":"Parallel Connection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"The algorithm simplifies the circuit by iteratively reducing the graph . This reduction involves identifying series and parallel connections and simplifying them step by step until only one node remains, representing the total equivalent resistance.","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-represent-the-circuit-as-a-graph","text":"Nodes : Each junction in the circuit is represented by a node in the graph. Edges : Each resistor is represented as an edge between two nodes, with the resistance as the weight of the edge. Example: Two resistors \\( R_1 = 6 \\, \\Omega \\) and \\( R_2 = 3 \\, \\Omega \\) in series: \\( R_1 \\) is connected to node 1, and \\( R_2 \\) is connected between node 2 and node 3. The graph representation has three nodes (1, 2, and 3) and two edges representing \\( R_1 \\) and \\( R_2 \\) .","title":"Step 1: Represent the Circuit as a Graph"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-detect-series-and-parallel-connections","text":"We will iteratively reduce the graph by simplifying the series and parallel connections.","title":"Step 2: Detect Series and Parallel Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connections","text":"If two resistors are in series (i.e., connected end-to-end), combine them by adding their resistance values. For two resistors \\( R_1 \\) and \\( R_2 \\) in series, the equivalent resistance is: $$ R_{eq} = R_1 + R_2 $$ This process is repeated until no more simple series connections are left.","title":"Series Connections:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connections","text":"If two resistors are in parallel (i.e., connected between the same two nodes), combine them using the parallel formula. For two resistors \\( R_1 \\) and \\( R_2 \\) in parallel, the equivalent resistance is: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ This process is repeated until no more simple parallel connections are left.","title":"Parallel Connections:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-3-iterative-graph-reduction","text":"After identifying and simplifying the series and parallel connections, the graph is reduced step-by-step: Identify series connections : Traverse the graph and check for resistors that are connected in series. Once identified, combine them by adding their resistance values. Identify parallel connections : Similarly, check for resistors that are connected in parallel. Combine them using the parallel resistance formula. Repeat the process : After each reduction (whether series or parallel), the graph is updated. New series or parallel connections may emerge from the simplification, so the process is repeated until the graph is reduced to a single equivalent resistance.","title":"Step 3: Iterative Graph Reduction"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-4-final-simplification","text":"The algorithm continues simplifying the circuit until only one node remains, and the resistance of this node is the equivalent resistance of the entire circuit.","title":"Step 4: Final Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode-for-the-algorithm","text":"Algorithm: Calculate Equivalent Resistance Using Graph Theory Input: Graph G with nodes representing junctions and edges representing resistors Output: Equivalent resistance of the entire circuit 1. Initialize the graph G with nodes and resistors (edges with weights). 2. While the graph contains more than one node: a. Detect and simplify **series connections**: - For each pair of nodes connected by resistors in series: - Combine the resistances by adding their weights. - Remove the original nodes and replace them with a new node that has the combined resistance. b. Detect and simplify **parallel connections**: - For each set of nodes connected by resistors in parallel: - Combine the resistances using the parallel formula. - Remove the original resistors and replace them with a new equivalent resistor. 3. Once the graph is reduced to a single node, return the equivalent resistance of that node.","title":"Pseudocode for the Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-solution-for-task-2-equivalent-resistance-calculation-using-graph-theory","text":"","title":"Step-by-Step Solution for Task 2: Equivalent Resistance Calculation Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-concepts","text":"","title":"Key Concepts:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-resistors","text":"The equivalent resistance of two resistors \\( R_1 \\) and \\( R_2 \\) in series is simply the sum: $$ R_{eq} = R_1 + R_2 $$","title":"Series Resistors:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistors","text":"The equivalent resistance of two resistors \\( R_1 \\) and \\( R_2 \\) in parallel is given by: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$","title":"Parallel Resistors:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation","text":"Nodes represent junctions in the circuit. Edges represent resistors with weights equal to their resistance values. The circuit is represented as an undirected graph, where the resistors are edges with weights, and the junctions are the nodes.","title":"Graph Representation:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#simplification-process","text":"Series Resistor Simplification: If two resistors are in series, their resistances add up. For nodes \\( A \\) , \\( B \\) , and \\( C \\) , where \\( A \\) is connected to \\( B \\) and \\( B \\) is connected to \\( C \\) , replace the two resistors (edges) with one equivalent resistor whose resistance is the sum of the two. $$ R_{eq} = R_1 + R_2 $$ After the simplification, remove the two original resistors and add a new one between \\( A \\) and \\( C \\) . Parallel Resistor Simplification: If two resistors are in parallel, their combined resistance is given by the formula: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_1} + \\frac{1}{R_2} $$ For nodes \\( A \\) , \\( B \\) , and \\( C \\) , where \\( A \\) is connected to \\( B \\) , and \\( B \\) is connected to \\( C \\) , replace the two resistors (edges) with one equivalent resistor using the formula above. Remove the two original resistors and add a new one between \\( A \\) and \\( C \\) .","title":"Simplification Process:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-process","text":"","title":"Step-by-Step Process:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-graph-creation","text":"First, a graph is created using the networkx library where: Nodes represent junctions in the circuit. Edges represent the resistors, with each edge having a weight representing the resistance value. Example: Resistor \\( R_1 = 6 \\) ohms between nodes 1 and 2. Resistor \\( R_2 = 3 \\) ohms between nodes 2 and 3. Resistor \\( R_3 = 4 \\) ohms between nodes 3 and 4. Resistor \\( R_4 = 5 \\) ohms between nodes 2 and 5. Resistor \\( R_5 = 2 \\) ohms between nodes 4 and 6.","title":"1. Graph Creation:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-series-resistor-detection","text":"Identify two resistors that are connected in series by looking for nodes that have exactly two neighbors. Apply the series simplification formula to these pairs and replace them with a single equivalent resistor. Example: If \\( R_1 \\) and \\( R_2 \\) are in series, their equivalent resistance will be: $$ R_{eq} = R_1 + R_2 $$ After simplification, update the graph with a new edge that represents the equivalent resistance.","title":"2. Series Resistor Detection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-parallel-resistor-detection","text":"Identify two resistors that are connected in parallel by looking for nodes that have two neighbors with the same connecting node. Apply the parallel simplification formula to these pairs and replace them with a single equivalent resistor. Example: If \\( R_2 \\) and \\( R_3 \\) are in parallel, their equivalent resistance will be: $$ \\frac{1}{R_{eq}} = \\frac{1}{R_2} + \\frac{1}{R_3} $$ After simplification, update the graph with a new edge that represents the equivalent resistance.","title":"3. Parallel Resistor Detection:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#4-repeat-simplification","text":"Continue the simplification process until only one edge remains in the graph. The remaining edge represents the equivalent resistance of the entire circuit.","title":"4. Repeat Simplification:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#5-final-result","text":"The final equivalent resistance is the weight of the last remaining edge in the graph, which is the simplified result of the entire circuit.","title":"5. Final Result:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-circuit","text":"","title":"Example Circuit:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation_1","text":"Nodes: \\( 1, 2, 3, 4, 5, 6 \\) Edges: \\( (1, 2, R_1 = 6 \\, \\Omega) \\) \\( (2, 3, R_2 = 3 \\, \\Omega) \\) \\( (3, 4, R_3 = 4 \\, \\Omega) \\) \\( (2, 5, R_4 = 5 \\, \\Omega) \\) \\( (4, 6, R_5 = 2 \\, \\Omega) \\) import networkx as nx import matplotlib.pyplot as plt # Function to plot the graph for visualization def plot_graph(G, title=\"Circuit Graph\"): pos = nx.spring_layout(G) # Layout for better visualization plt.figure(figsize=(10, 8)) node_size = [500 + 100 * G.degree(node) for node in G.nodes] node_color = ['lightgreen' if G.degree(node) == 1 else 'lightblue' for node in G.nodes] nx.draw(G, pos, with_labels=True, node_color=node_color, node_size=node_size, font_size=15, font_weight=\"bold\", edge_color=\"gray\") edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=12) plt.title(title) plt.axis('off') # Hide axes for a cleaner presentation plt.show() # Function to find series resistors def find_series_resistors(G): series_pairs = [] for node in G.nodes: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Exactly two neighbors for series connection if G[node][neighbors[0]]['weight'] and G[node][neighbors[1]]['weight']: series_pairs.append((node, neighbors[0], neighbors[1])) return series_pairs # Function to find parallel resistors def find_parallel_resistors(G): parallel_pairs = [] for node in G.nodes: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Exactly two neighbors for parallel connection if G[node][neighbors[0]]['weight'] and G[node][neighbors[1]]['weight']: parallel_pairs.append((node, neighbors[0], neighbors[1])) return parallel_pairs # Function to simplify a series resistor def simplify_series(G, series_pair): node1, node2, node3 = series_pair R1 = G[node2][node1]['weight'] R2 = G[node3][node2]['weight'] R_eq = R1 + R2 # Series combination # Remove the two resistors and add the equivalent one G.remove_edge(node2, node1) G.remove_edge(node3, node2) G.add_edge(node1, node3, weight=R_eq) return G # Function to simplify a parallel resistor def simplify_parallel(G, parallel_pair): node1, node2, node3 = parallel_pair R1 = G[node1][node2]['weight'] R2 = G[node2][node3]['weight'] R_eq = 1 / (1 / R1 + 1 / R2) # Parallel combination # Remove the two resistors and add the equivalent one G.remove_edge(node1, node2) G.remove_edge(node2, node3) G.add_edge(node1, node3, weight=R_eq) return G # Main function to calculate equivalent resistance def calculate_equivalent_resistance(G): # Initial graph plot plot_graph(G, title=\"Initial Circuit Graph\") step = 1 # Keep simplifying the graph until only one edge remains while len(G.edges) > 1: # Simplify series connections series_pairs = find_series_resistors(G) if series_pairs: print(f\"Step {step}: Simplifying series pairs: {series_pairs}\") for series_pair in series_pairs: G = simplify_series(G, series_pair) # Plot after simplifying series resistors plot_graph(G, title=f\"After Step {step}: Simplified Series Resistors\") # Simplify parallel connections parallel_pairs = find_parallel_resistors(G) if parallel_pairs: print(f\"Step {step}: Simplifying parallel pairs: {parallel_pairs}\") for parallel_pair in parallel_pairs: G = simplify_parallel(G, parallel_pair) # Plot after simplifying parallel resistors plot_graph(G, title=f\"After Step {step}: Simplified Parallel Resistors\") step += 1 # The final equivalent resistance is the only edge left in the graph final_resistance = None for edge in G.edges(data=True): final_resistance = edge[2]['weight'] return final_resistance # Example usage: Create a circuit graph G = nx.Graph() # Adding resistors (edges) to the circuit # Resistor values: R1 = 6 ohms, R2 = 3 ohms, R3 = 4 ohms, R4 = 5 ohms, R5 = 2 ohms G.add_edge(1, 2, weight=6) # R1 G.add_edge(2, 3, weight=3) # R2 G.add_edge(3, 4, weight=4) # R3 G.add_edge(2, 5, weight=5) # R4 G.add_edge(4, 6, weight=2) # R5 # Call the function to calculate the equivalent resistance equivalent_resistance = calculate_equivalent_resistance(G) print(f\"The equivalent resistance of the circuit is: {equivalent_resistance} ohms\")","title":"Graph Representation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Exploring the Central Limit Theorem through Simulations Task Overview: This task involves exploring the Central Limit Theorem (CLT) through simulations with different population distributions. You\u2019ll generate datasets representing different populations, sample from these populations, and analyze the sample means as the sample size increases. By plotting histograms of the sample means, we can observe the convergence to a normal distribution and discuss the implications of these results. Plan: We\u2019ll proceed with the following steps: Simulating Sampling Distributions using several population distributions (Uniform, Exponential, and Binomial). Sampling and Visualization : Sampling data from the population and visualizing the sample mean distributions. Parameter Exploration : Investigating how sample size and population shape influence convergence to normality. Practical Applications : Discussing the real-world implications of the Central Limit Theorem. 1. Simulating Sampling Distributions: We'll start by generating large datasets for each population distribution. We\u2019ll use Python\u2019s numpy to generate these distributions and the matplotlib and seaborn libraries for visualization. Population Distributions: Uniform Distribution : Random values between a range (e.g., 0 and 1). Exponential Distribution : Values from an exponential distribution with a given rate. Binomial Distribution : Values representing the number of successes in a fixed number of trials with a certain probability. 2. Sampling and Visualization: For each distribution, we will: Randomly sample data for different sample sizes (5, 10, 30, 50). Calculate the sample means. Repeat the sampling process to create the sampling distribution of the sample mean. Plot the histograms of the sample means to observe the convergence toward normality. 3. Code Implementation: import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import skew, kurtosis import scipy.stats as stats # Function to generate sample means def sample_means(population, sample_size, num_samples): means = [] for _ in range(num_samples): sample = np.random.choice(population, sample_size) means.append(np.mean(sample)) return means # Function to plot histograms of sample means with theoretical normal distribution overlay def plot_histogram(data_dict, population, title): plt.figure(figsize=(14, 10), dpi=200) # Increased figure size and high DPI for better resolution for size, data in data_dict.items(): sns.histplot(data, kde=True, label=f'Sample size {size}', stat=\"density\", linewidth=0, bins=30, alpha=0.6) # Overlay a normal distribution with the same mean and standard deviation mean = np.mean(data) std = np.std(data) x = np.linspace(min(data), max(data), 100) plt.plot(x, stats.norm.pdf(x, mean, std), label=f'Normal Approx (size {size})', linestyle='--', linewidth=2) # Original population distribution plot sns.histplot(population, kde=True, label='Original Population', color='gray', stat=\"density\", linewidth=2, bins=30) # Title, axis labels, and formatting improvements plt.title(f'{title} - Sampling Distributions of Sample Means vs Population Distribution', fontsize=18) plt.xlabel('Value', fontsize=14) plt.ylabel('Density', fontsize=14) plt.legend(title='Distribution', loc='best', fontsize=12) plt.grid(True, linestyle='--', alpha=0.7) plt.tight_layout() # Adjust layout to avoid overlapping elements plt.show() # Function to calculate sample variance and standard error def sample_variance(data_dict): variance = {size: np.var(data) for size, data in data_dict.items()} std_error = {size: np.std(data) / np.sqrt(size) for size, data in data_dict.items()} return variance, std_error # Function to calculate skewness and kurtosis def skewness_kurtosis(data_dict): skewness = {size: skew(data) for size, data in data_dict.items()} kurt = {size: kurtosis(data) for size, data in data_dict.items()} return skewness, kurt # Population size population_size = 100000 # Generating populations uniform_population = np.random.uniform(0, 1, population_size) # Uniform distribution exponential_population = np.random.exponential(1, population_size) # Exponential distribution binomial_population = np.random.binomial(n=100, p=0.5, size=population_size) # Binomial distribution # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Number of samples to draw # Generating sample means for different sample sizes and distributions uniform_means = {size: sample_means(uniform_population, size, num_samples) for size in sample_sizes} exponential_means = {size: sample_means(exponential_population, size, num_samples) for size in sample_sizes} binomial_means = {size: sample_means(binomial_population, size, num_samples) for size in sample_sizes} # Plotting histograms for each distribution and comparing with population plot_histogram(uniform_means, uniform_population, 'Uniform Distribution') plot_histogram(exponential_means, exponential_population, 'Exponential Distribution') plot_histogram(binomial_means, binomial_population, 'Binomial Distribution') # Calculating variance, standard error, skewness, and kurtosis uniform_variance, uniform_se = sample_variance(uniform_means) exponential_variance, exponential_se = sample_variance(exponential_means) binomial_variance, binomial_se = sample_variance(binomial_means) uniform_skewness, uniform_kurt = skewness_kurtosis(uniform_means) exponential_skewness, exponential_kurt = skewness_kurtosis(exponential_means) binomial_skewness, binomial_kurt = skewness_kurtosis(binomial_means) # Printing results print(\"Uniform variance by sample size:\", uniform_variance) print(\"Exponential variance by sample size:\", exponential_variance) print(\"Binomial variance by sample size:\", binomial_variance) print(\"\\nUniform standard error by sample size:\", uniform_se) print(\"Exponential standard error by sample size:\", exponential_se) print(\"Binomial standard error by sample size:\", binomial_se) print(\"\\nUniform skewness by sample size:\", uniform_skewness) print(\"Exponential skewness by sample size:\", exponential_skewness) print(\"Binomial skewness by sample size:\", binomial_skewness) print(\"\\nUniform kurtosis by sample size:\", uniform_kurt) print(\"Exponential kurtosis by sample size:\", exponential_kurt) print(\"Binomial kurtosis by sample size:\", binomial_kurt)","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exploring-the-central-limit-theorem-through-simulations","text":"","title":"Exploring the Central Limit Theorem through Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-overview","text":"This task involves exploring the Central Limit Theorem (CLT) through simulations with different population distributions. You\u2019ll generate datasets representing different populations, sample from these populations, and analyze the sample means as the sample size increases. By plotting histograms of the sample means, we can observe the convergence to a normal distribution and discuss the implications of these results.","title":"Task Overview:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#plan","text":"We\u2019ll proceed with the following steps: Simulating Sampling Distributions using several population distributions (Uniform, Exponential, and Binomial). Sampling and Visualization : Sampling data from the population and visualizing the sample mean distributions. Parameter Exploration : Investigating how sample size and population shape influence convergence to normality. Practical Applications : Discussing the real-world implications of the Central Limit Theorem.","title":"Plan:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"We'll start by generating large datasets for each population distribution. We\u2019ll use Python\u2019s numpy to generate these distributions and the matplotlib and seaborn libraries for visualization.","title":"1. Simulating Sampling Distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#population-distributions","text":"Uniform Distribution : Random values between a range (e.g., 0 and 1). Exponential Distribution : Values from an exponential distribution with a given rate. Binomial Distribution : Values representing the number of successes in a fixed number of trials with a certain probability.","title":"Population Distributions:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-sampling-and-visualization","text":"For each distribution, we will: Randomly sample data for different sample sizes (5, 10, 30, 50). Calculate the sample means. Repeat the sampling process to create the sampling distribution of the sample mean. Plot the histograms of the sample means to observe the convergence toward normality.","title":"2. Sampling and Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-code-implementation","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns from scipy.stats import skew, kurtosis import scipy.stats as stats # Function to generate sample means def sample_means(population, sample_size, num_samples): means = [] for _ in range(num_samples): sample = np.random.choice(population, sample_size) means.append(np.mean(sample)) return means # Function to plot histograms of sample means with theoretical normal distribution overlay def plot_histogram(data_dict, population, title): plt.figure(figsize=(14, 10), dpi=200) # Increased figure size and high DPI for better resolution for size, data in data_dict.items(): sns.histplot(data, kde=True, label=f'Sample size {size}', stat=\"density\", linewidth=0, bins=30, alpha=0.6) # Overlay a normal distribution with the same mean and standard deviation mean = np.mean(data) std = np.std(data) x = np.linspace(min(data), max(data), 100) plt.plot(x, stats.norm.pdf(x, mean, std), label=f'Normal Approx (size {size})', linestyle='--', linewidth=2) # Original population distribution plot sns.histplot(population, kde=True, label='Original Population', color='gray', stat=\"density\", linewidth=2, bins=30) # Title, axis labels, and formatting improvements plt.title(f'{title} - Sampling Distributions of Sample Means vs Population Distribution', fontsize=18) plt.xlabel('Value', fontsize=14) plt.ylabel('Density', fontsize=14) plt.legend(title='Distribution', loc='best', fontsize=12) plt.grid(True, linestyle='--', alpha=0.7) plt.tight_layout() # Adjust layout to avoid overlapping elements plt.show() # Function to calculate sample variance and standard error def sample_variance(data_dict): variance = {size: np.var(data) for size, data in data_dict.items()} std_error = {size: np.std(data) / np.sqrt(size) for size, data in data_dict.items()} return variance, std_error # Function to calculate skewness and kurtosis def skewness_kurtosis(data_dict): skewness = {size: skew(data) for size, data in data_dict.items()} kurt = {size: kurtosis(data) for size, data in data_dict.items()} return skewness, kurt # Population size population_size = 100000 # Generating populations uniform_population = np.random.uniform(0, 1, population_size) # Uniform distribution exponential_population = np.random.exponential(1, population_size) # Exponential distribution binomial_population = np.random.binomial(n=100, p=0.5, size=population_size) # Binomial distribution # Sample sizes to test sample_sizes = [5, 10, 30, 50] num_samples = 1000 # Number of samples to draw # Generating sample means for different sample sizes and distributions uniform_means = {size: sample_means(uniform_population, size, num_samples) for size in sample_sizes} exponential_means = {size: sample_means(exponential_population, size, num_samples) for size in sample_sizes} binomial_means = {size: sample_means(binomial_population, size, num_samples) for size in sample_sizes} # Plotting histograms for each distribution and comparing with population plot_histogram(uniform_means, uniform_population, 'Uniform Distribution') plot_histogram(exponential_means, exponential_population, 'Exponential Distribution') plot_histogram(binomial_means, binomial_population, 'Binomial Distribution') # Calculating variance, standard error, skewness, and kurtosis uniform_variance, uniform_se = sample_variance(uniform_means) exponential_variance, exponential_se = sample_variance(exponential_means) binomial_variance, binomial_se = sample_variance(binomial_means) uniform_skewness, uniform_kurt = skewness_kurtosis(uniform_means) exponential_skewness, exponential_kurt = skewness_kurtosis(exponential_means) binomial_skewness, binomial_kurt = skewness_kurtosis(binomial_means) # Printing results print(\"Uniform variance by sample size:\", uniform_variance) print(\"Exponential variance by sample size:\", exponential_variance) print(\"Binomial variance by sample size:\", binomial_variance) print(\"\\nUniform standard error by sample size:\", uniform_se) print(\"Exponential standard error by sample size:\", exponential_se) print(\"Binomial standard error by sample size:\", binomial_se) print(\"\\nUniform skewness by sample size:\", uniform_skewness) print(\"Exponential skewness by sample size:\", exponential_skewness) print(\"Binomial skewness by sample size:\", binomial_skewness) print(\"\\nUniform kurtosis by sample size:\", uniform_kurt) print(\"Exponential kurtosis by sample size:\", exponential_kurt) print(\"Binomial kurtosis by sample size:\", binomial_kurt)","title":"3. Code Implementation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}